/*
 Navicat Premium Data Transfer

 Source Server         : MySQL
 Source Server Type    : MySQL
 Source Server Version : 80011
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80011
 File Encoding         : 65001

 Date: 22/07/2019 19:34:51
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `aid` int(11) NOT NULL AUTO_INCREMENT,
  `acid` int(11) DEFAULT NULL,
  `uid` int(11) DEFAULT NULL,
  `title` tinytext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `tag` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `publishTime` date DEFAULT NULL,
  `likeCount` int(11) DEFAULT NULL,
  `scanCount` int(11) DEFAULT NULL,
  `content` text CHARACTER SET utf8 COLLATE utf8_general_ci,
  PRIMARY KEY (`aid`) USING BTREE,
  INDEX `acid`(`acid`) USING BTREE,
  INDEX `uid`(`uid`) USING BTREE,
  CONSTRAINT `article_ibfk_1` FOREIGN KEY (`acid`) REFERENCES `articlecategory` (`acid`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `article_ibfk_2` FOREIGN KEY (`uid`) REFERENCES `user` (`uid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (2, 1, 1, 'JDK1.6之后的锁优化', 'java', '2019-06-06', 6, 0, '## 一、概述\n高效并发是从JDK1.5到JDK1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如适应性自旋 (Adaptive Spinning) 、锁消除 (Lock Elimination) 、锁粗化 (Lock Coarsening) 、轻量级锁 (Lightweight Locking) 和偏向锁 (Biased Locking) 等，这些技术都是为了在线程之间更高效的共享数据，以及解决竞争问题，从而提高程序的执行效率。\n\n<!-- more -->\n\n## 二、自旋锁和适应性自旋\n互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来的很大的压力。而在很多的应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段很短的时间去挂起和恢复线程是很不值得的。所以虚拟机的开发团队就这样考虑：“我们可不可以让后面请求锁的那个线程稍微等一下，但并不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。”为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。\n\n自旋锁在 JDK1.4.2 中就已经引入了，只不过是默认关闭的，可以使用 -XX:+UseSpinning 参数来开启，在 JDK1.6 中已经改为默认开启了。自旋锁不能代替阻塞，因为自旋锁虽然避免了线程切换的开销，但它还是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白的消耗处理器资源，而不会做任何有意义的工作，反而会带来性能上的浪费。因此，自旋等待的时间必须要有一定的限度，如果自旋超过的限定的次数任然没有成功获得锁，就应该使用传统的方式去挂起线程。自旋次数的默认值是10次，用户可以使用参数 -XX:PreBlockSpin 来更改。\n\n在 JDK1.6 中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这一次的自旋很有可能再次成功，进而他允许自旋等待相对更长的时间，例如 100 个循环。另外，如果对于某个锁，自旋很少成功获得过，那么以后在获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。\n## 三、锁消除\n锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断哪依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步枷锁自然就无需进行。（关于逃逸分析技术可参考《深入理解Java虚拟机---JVM高级特性与最佳实战》）\n## 四、锁粗化\n原则上，我们在编写代码的时候，总是推荐将同步快的作用范围限制的得尽量小，即只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能的小，如果存在竞争，那等待锁的线程也能尽快拿到锁。大部分情况下，这样的原则都是对的，但是如果一系列的连续操作都对同一个对象反复的加锁和解锁，甚至加锁操作出现在循环体中，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能消耗。\n\n如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样就只需要加锁一次就够了。\n## 五、轻量级锁\n轻量级锁是 JDK1.6 之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。轻量级锁能提升程序同步性能的依据是**对于绝大部分的锁，在整个同步周期内都是不存在竞争的**，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销之外，还额外发生了 CAS 操作，因此在由竞争的情况下，轻量级锁回避传统的重量级锁更慢。\n## 六、偏向锁\n偏向锁也是 JDK1.6 中引入的一项锁优化，它的目的是**消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能**。如果说轻量级锁实在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连 CAS 操作都不做了。偏向锁的意思是这个锁会偏向于第一个获得他的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。\n\n偏向锁可以提高带有同步但无竞争的程序性能。它同样是一个带有效益权衡性质的优化，它并不一定总是对程序运行有利，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。在具体问题具体分析的前提下，有时候使用参数 -XX:-UseBiasedLocking 来禁用偏向锁优化反而可以提升性能。\n\n关于轻量级锁和偏向锁理解的不是很透彻，后续还会完善一下。。。\n## 七、synchronized 和 ReentrantLock 的比较\n+ **两者都是可重入锁**\n两者都是可重入锁，可重入锁是指：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。\n+ synchronized 表现为原生语法 (JVM) 层面的互斥锁，ReentrantLock 则表现为 API 层面的互斥锁（需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）。\n+ 相比 synchronized ，ReentrantLock 增加了一些高级功能，主要有以下三项：**等待可中断**，**可实现公平锁**，**锁可以绑定多个条件（可实现选择性通知）**。\n  + 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他的事情，可中断特性对处理执行时间非常长的同步快非常有帮助。\n```java\n/**\n * ReentrantLock为我们提供了一个可以相应中断的获取锁的方法lockInterruptibly()，该方法可以用来解决死锁问题\n *\n * 构造死锁场景：创建两个子线程,子线程在运行时会分别尝试获取两把锁。其中一个线程先获取锁1再获取锁2，另一个线程正好相反。\n * 如果没有外界中断，该程序将处于死锁状态永远无法停止。我们通过使其中一个线程中断，来结束线程间毫无意义的等待。\n * 被中断的线程将抛出异常，而另一个线程将能获取锁后正常结束。\n */\npublic class ReentrantLockTest {\n\n    static Lock lockOne = new ReentrantLock();\n\n    static Lock lockTwo = new ReentrantLock();\n\n    public static void main(String[] args) {\n        Thread threadOne = new Thread(new Task(lockOne, lockTwo));\n        Thread threadTwo = new Thread(new Task(lockTwo, lockOne));\n        threadOne.start();\n        threadTwo.start();\n        threadOne.interrupt();//中断第一个线程\n    }\n\n    static class Task implements Runnable {\n        Lock firstLock;\n        Lock secondLock;\n\n        public Task(Lock firstLock, Lock secondLock) {\n            this.firstLock = firstLock;\n            this.secondLock = secondLock;\n        }\n\n        @Override\n        public void run() {\n            try {\n                firstLock.lockInterruptibly();\n                TimeUnit.MILLISECONDS.sleep(10);\n                secondLock.lockInterruptibly();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                firstLock.unlock();\n                secondLock.unlock();\n                System.out.println(Thread.currentThread().getName() + \"正常结束!\");\n            }\n        }\n    }\n}\n```\n  + 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁不保证这一点，任何一个等待锁的线程都有机会获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带有布尔值的构造函数要求使用公平锁。\n```java\npublic class ReentrantLockTest {\n\n    static Lock lock = new ReentrantLock(true);\n\n    static class Task implements Runnable {\n        \n        Integer id;\n\n        public Task(Integer id) {\n            this.id = id;\n        }\n\n        @Override\n        public void run() {\n            try {\n                TimeUnit.MILLISECONDS.sleep(10);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            for (int i = 0; i < 2; i++) {\n                lock.lock();\n                System.out.println(\"获得锁的线程：\" + id);\n                lock.unlock();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++) {\n            new Thread(new Task(i)).start();\n        }\n    }\n}\n```\n  + 锁绑定多个条件是指一个 ReentrantLock 对象可以同时绑定多个 Condition 对象，而在 synchronized 中，锁对象的 wait() 和 notify() 或 notifyAll() 方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外的添加一个锁，而 ReentrantLock 无须这样做，只需要多次调用 newCondition() 即可。\n```java\n/**\n * 使用ReentrantLock和Condition实现简单的阻塞列队\n * 阻塞列队的特点：\n *      1、入队和出队线程安全\n *      2、当列队满时，入队线程会被阻塞；当列队为空时，出队线程会被阻塞\n */\npublic class MyBlockingQueue<E> {\n\n    private int size;       //阻塞队列最大容量\n\n    private ReentrantLock lock = new ReentrantLock();\n\n    private LinkedList<E> list = new LinkedList<>();      //队列底层实现\n\n    Condition notFull = lock.newCondition();        //队列满时的等待条件\n    Condition notEmpty = lock.newCondition();       //队列空时的等待条件\n\n    public MyBlockingQueue(int size) {\n        this.size = size;\n    }\n\n    public void enqueue(E e) throws InterruptedException {\n        lock.lock();\n        try {\n            while (list.size() == size)     //队列已满, 在notFull条件上等待\n                notFull.await();\n            list.add(e);        //入队: 加入链表末尾\n            System.out.println(\"入队：\" + e);\n            notEmpty.signal();      //通知在notEmpty条件上等待的线程\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public E dequeue() throws InterruptedException {\n        E e;\n        lock.lock();\n        try {\n            while (list.size() == 0)        //队列为空, 在notEmpty条件上等待\n                notEmpty.await();\n            e = list.removeFirst();     //出队: 移除链表首元素\n            System.out.println(\"出队：\" + e);\n            notFull.signal();       //通知在notFull条件上等待的线程\n            return e;\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        MyBlockingQueue<Integer> queue = new MyBlockingQueue<>(2);\n        for (int i = 0; i < 10; i++) {\n            int data = i;\n            new Thread(() -> {\n                try {\n                    queue.enqueue(data);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n        for (int i = 0; i < 10; i++) {\n            new Thread(() -> {\n                try {\n                    Integer data = queue.dequeue();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }).start();\n        }\n    }\n}\n```\n\n如果需要使用上诉功能，选用 Reentrantlock 是一个很好的选择。在性能方面，JDK1.6 之前，多线程环境下 synchronized 的吞吐量随着线程数量的增加下降得非常严重，而 ReentrantLock 则能基本保持在一个比较稳定的水平上。与其说 ReentrantLock 性能好，还不如说 synchronized 还有非常大的优化余地。后续的技术发展也证明了这一点，JDK1.6 中加入了很多针对锁的优化措施（如上所诉）。在 JDK1.6 发布之后，synchronized 和 ReentrantLock 的性能基本上是完全持平了。因此性能因素就不再是选择 ReentrantLock 的理由了，虚拟机在未来的性能改进中肯定也会更加偏向于原生的 synchronized，所以还是提倡在 synchronized 能实现需求的情况下，优先考虑使用 synchronized 来进行同步。\n\n参考：\n《深入理解 Java 虚拟机：JVM 高级特性与最佳实战》\nhttps://github.com/Snailclimb/JavaGuide/blob/master/docs/java/synchronized.md\nReentrantLock 的使用方法参考：https://www.cnblogs.com/takumicx/p/9338983.html#reentrantlock%E5%8F%AF%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD\n\n');
INSERT INTO `article` VALUES (3, 1, 1, 'Compare-and-Swap', 'java', '2019-06-08', 12, 14, '在并发编程中，互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步 (Blocking Synchronization)。从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步策略（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上 JVM 会优化掉很大一部分不必要的加锁）、用户态和核态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展，我们有了另一个选择：基于冲突检测的乐观并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那么操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断的重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。\n\n<!-- more -->\n\n为什么说使用乐观并发策略需要“硬件指令集的发展”才能进行呢？因为我们需要操作和冲突检测这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：\n+ 测试并设置（Test-and-Set）\n+ 获取并增加（Fetch-and-Increment）\n+ 交换（Swap）\n+ 比较并交换（Compare-and-Swap, CAS）\n+ 加载链接（Load-Linked/Store-Conditional, LL/SC）\n\n其中，前面三条是 20 世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能是类似的。在 IA64、x86 指令集中有 cmpxchg 指令完成 CAS 功能，在 sparc-TSO 也有 casa 指令实现，而在 ARM 和 PowerPC 架构下，则需要使用一对 ldrex/strex 指令来完成 LL/SC 功能。\n## CAS操作\nCAS 指令需要有三个操作数，分别是内存位置（在 Java 中可以简单地理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则他就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的操作过程是一个原子操作。\n\n在 JDK1.5 之后，Java 程序中才能使用 CAS 操作，该操作由 sun.misc.Unsafe 类里面的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令，没有方法调用的过程，或者可以认为是无条件内联进去了（这种被虚拟机特殊处理的方法称为固有函数（Intrinsics），类似的固有函数还有 Math.sin() 等）。由于 Unsafe 类不是提供给用户程序调用的类（Unsafe.getUnfase() 的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的 Class 才能访问它），因此，如果不采用反射手段，我们只能通过其他的 Java API 来间接使用它，如 J.U.C 包里面的整数原子类，其中的 compareAndSet() 和 getAndIncrement() 等方法都是使用了 Unsafe 类的 CAS 操作。下面使用 Unsafe 类实现一个简单的 AtomicInteger：\n```java\nimport sun.misc.Unsafe;\n\nimport java.lang.reflect.Field;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class UnsafeTest {\n\n    public static void main(String[] args) throws Exception {\n        MyInteger myInteger = new MyInteger(0);\n        ExecutorService service = Executors.newFixedThreadPool(20);\n        for (int cnt = 0; cnt < 20; cnt++) {\n            service.execute(() -> {\n                for (int i = 0; i < 10000; i++)\n                    myInteger.increaseAndGet();\n            });\n        }\n        service.shutdown();\n        /* 等待线程池中的所有线程执行完毕 */\n        while (Thread.activeCount() > 2)\n            Thread.yield();\n        System.out.println(myInteger.getValue());\n    }\n}\n\nclass MyInteger {\n\n    private int value;\n\n    private static Unsafe unsafe;\n\n    /* 表示 value 相对于 MyInteger 实例起始地址的偏移量 */\n    private static long valueOffset;\n\n    public MyInteger(int value) throws Exception {\n        this.value = value;\n\n        /* 使用反射才能获得 Unsafe 实例 */\n        Field field = Unsafe.class.getDeclaredField(\"theUnsafe\");\n        field.setAccessible(true);\n        unsafe = (Unsafe) field.get(Unsafe.class);\n\n        field = MyInteger.class.getDeclaredField(\"value\");\n        valueOffset = unsafe.objectFieldOffset(field);\n    }\n\n    public int increaseAndGet() {\n        while (true) {\n            int current = value;\n            int next = value + 1;\n            if (unsafe.compareAndSwapInt(this, valueOffset, current, next) == true)\n                return next;\n        }\n    }\n\n    public int getValue() {\n        return value;\n    }\n}\n```\n其中，increaseAndGet() 方法在一个无限循环当中，不断尝试将一个比当前值大一的新值赋值给自己。如果失败，那说明在执行 “获取-设置” 操作期间有其他线程修改 value 的值，于是再次循环进行下一次操作，直到设置成功为止。\n## ABA 问题\n尽管 CAS 看起来很棒，但显然这种操作无法涵盖互斥同步的所有使用场景，并且 CAS 从语义上来说并不是完美的，存在这样一个逻辑漏洞：如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它任然为 A 值，那我们就能说它的值没有被其他线程改变过了吗？如果在这期间它的值曾经被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为变量 V 从来没有被改变过。这个漏洞称为 CAS 操作的 ABA 问题。J.U.C 包为了解决这个问题，提供了一个带有标记的原子引用类 AtomicStampedReference，他可以通过控制变量值的版本来保证 CAS 的正确性。不过目前来说这个类比较鸡肋，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更加高效。ABA 问题样例：\n```java\nimport java.util.concurrent.atomic.AtomicInteger;\n\npublic class CAS_ABA_Q {\n\n    public static AtomicInteger a = new AtomicInteger(1);\n\n    public static void main(String[] args){\n        Thread main = new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \",初始值 = \" + a);\n            try {\n                Thread.sleep(1000);     //等待1秒 ，以便让干扰线程执行\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            boolean isCASSuccess = a.compareAndSet(1, 2);\n            System.out.println(Thread.currentThread().getName() + \"---CAS操作结果: \" + isCASSuccess);\n        }, \"主操作线程\");\n\n        Thread other = new Thread(() -> {\n            try {       //确保让main线程优先执行\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            a.incrementAndGet();\n            System.out.println(Thread.currentThread().getName() + \", [increment], a = \" + a);\n            a.decrementAndGet();\n            System.out.println(Thread.currentThread().getName() + \", [decrement], a = \" + a);\n        }, \"干扰线程\");\n\n        main.start();\n        other.start();\n    }\n}\n```\n### 使用 AtomicStampedReference 类解决 ABA 问题\nAtomicStampedReference 原子类是一个带有类似于版本号的对象引用，在每次修改后，AtomicStampedReference 不仅会设置新值而且还会记录更改的版本号。当 AtomicStampedReference 设置对象值时，对象值以及版本号都必须满足期望值才能写入成功，这也就解决了反复读写时，无法预知值是否已被修改的窘境。AtomicStampedReference 底层是通过一个叫 Pair 的私有内部类来存储数据和版本号，并构造 valotile 修饰的私有实例。AtomicStampedReference 类的 compareAndSet() 方法在更新时对数据和版本号同时进行比较，只有两者都符合预期时才会调用 casPair() 方法，而 casPair() 方法最终还是调用的 Unsafe 类的方法。compareAndSet() 源码如下：\n```java\npublic boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) {\n        Pair<V> current = pair;\n        return expectedReference == current.reference && expectedStamp == current.stamp &&\n            ((newReference == current.reference && newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));\n    }\n```\n使用 AtomicStampedReference 类解决 ABA 问题：\n```java\nimport java.util.concurrent.atomic.AtomicStampedReference;\n\npublic class CAS_ABA_A {\n\n    private static AtomicStampedReference<Integer> atomicStampedRef =\n        new AtomicStampedReference<>(1, 0);\n\n    public static void main(String[] args) {\n        Thread main = new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \", 初始值 a = \" + atomicStampedRef.getReference());\n            int stamp = atomicStampedRef.getStamp();        //获取当前标识别\n            try {\n                Thread.sleep(1000);     //等待1秒 ，以便让干扰线程执行\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            /* //此时 expectedReference 未发生改变，但是 stamp 已经被修改了，所以CAS失败 */\n            boolean isCASSuccess = atomicStampedRef.compareAndSet(1, 2, stamp, stamp + 1);\n            System.out.println(Thread.currentThread().getName() + \", CAS操作结果: \" + isCASSuccess);\n        }, \"主操作线程\");\n\n        Thread other = new Thread(() -> {\n            try {       //确保让main线程优先执行\n                Thread.sleep(500);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            atomicStampedRef.compareAndSet(1, 2, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + \", [increment], a = \" + atomicStampedRef.getReference());\n            atomicStampedRef.compareAndSet(2, 1, atomicStampedRef.getStamp(), atomicStampedRef.getStamp() + 1);\n            System.out.println(Thread.currentThread().getName() + \", [decrement], a = \" + atomicStampedRef.getReference());\n        }, \"干扰线程\");\n\n        main.start();\n        other.start();\n    }\n}\n```\n### AtomicMarkableReference 类\nAtomicMarkableReference 的实现原理与 AtomicStampedReference 类似，只不过 AtomicMarkableReference 与 AtomicStampedReference 不同的是，AtomicMarkableReference 维护的是一个 boolean 类型的标识，也就是说标识会在 true 和 false 两种状态之间切换。经过测试，这种方式并不能完全防止 ABA 问题的发生，只能减少 ABA 问题发生的概率。所以，如果要完全杜绝 ABA 问题的发生，应该使用 AtomicStampedReference 原子类更新对象，而对于 AtomicMarkableReference 来说只能减少 ABA 问题的发生概率，并不能杜绝。\n\n参考：\nhttps://www.jianshu.com/p/8b227a8adbc1\nhttps://blog.csdn.net/mmoren/article/details/79185862\n');
INSERT INTO `article` VALUES (8, 2, 9, 'LockSupport', 'java', '2019-06-20', 0, 0, 'LockSupport 是用于创建锁和其他同步类的基本线程阻塞原语。\n\n### 一、使用\n在没有 LockSupport 之前，线程的挂起和唤醒通常是通过 wait 和 notify 来实现，并且 wait 和 notify 只能在 synchronized 同步语句块中调用。例如：\n\n<!-- more -->\n\n```java\npublic class WaitAndNotify {\n\n    public static void main(String[] args) throws InterruptedException {\n        final Object object = new Object();\n        new Thread(() -> {\n            System.out.println(\"minor thread start!\");\n            synchronized (object) {\n                try {\n                    object.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println(\"minor thread end!\");\n        }).start();\n\n        Thread.sleep(1000);\n        synchronized (object) {\n            System.out.println(\"minor thread wake up by main thread!\");\n            object.notify();\n        }\n    }\n}\n\n/*\n    minor thread start!\n    minor thread wake up by main thread!\n    minor thread end!\n */\n```\nwait 和 notify 不仅要保证在 synchronized 同步语句块中使用，还要保证使用的顺序，即先 wait 再 notify，否则被挂起的线程永远不会被唤醒。而使用 LockSupport 就相对简单得多，只需调用 park() 和 unpark() 方法，而且不用在意两者的调用顺序。例如：\n```java\nimport java.util.concurrent.locks.LockSupport;\n\npublic class LockSupportTest {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread minor = new Thread(() -> {\n            System.out.println(\"minor thread start!\");\n            LockSupport.park();\n            System.out.println(\"minor thread end!\");\n        });\n        minor.start();\n\n        System.out.println(\"minor thread wake up by main thread!\");\n        LockSupport.unpark(minor);\n    }\n}\n\n/*\n    minor thread wake up by main thread!\n    minor thread start!\n    minor thread end!\n */\n```\n\n### 二、解析\n从上面的例子中可以看到，LockSupport 通过使用 pack 挂起线程，unpark 唤醒线程。在 LockSupport 中有一个许可（permit）的概念，LockSupport 也是通过这个许可来实现线程的挂起和唤醒。可以简单地按照如下逻辑理解：\n+ 调用 park() 时，如果线程的 permit 存在，那么该 permit 被消耗，线程不会被挂起，park() 方法立即返回。如果 permit 不存在，则认为线程缺少 permit，挂起线程等待 permit。（一个线程默认是没有 permit 的）\n+ 调用 unpark() 时，如果线程的 permit 不存在，则释放一个 permit，因为有了 permit，所以如果线程处于挂起状态，那么此线程会被线程调度器唤醒。如果线程的 permit 存在，permit 不会累加，看起来就像什么都没做一样。正因为 permit 不能累加，相当于只有一个，所以 LockSupport 是不可重入的，而且调用 park() 和 unpark() 的先后顺序也就不那么重要了。\n\n### 三、源码\n##### parkBlockerOffset\n```java\n    private static final sun.misc.Unsafe UNSAFE;\n    private static final long parkBlockerOffset;\n    ···\n    static {\n        try {\n            UNSAFE = sun.misc.Unsafe.getUnsafe();\n            Class<?> tk = Thread.class;\n            parkBlockerOffset = UNSAFE.objectFieldOffset\n                (tk.getDeclaredField(\"parkBlocker\"));\n            ···\n        } catch (Exception ex) { throw new Error(ex); }\n    }\n```\n在 Thread 类中有一个成员变量 parkBlocker，这个 parkBlocker 在线程因为使用 LockSupport 被阻塞时会被记录下来，这样监视工具和诊断工具就可以确定线程受阻塞的原因。这个 parkBlocker 也只能在 LockSupport 中被设置和访问。从上面的静态语句块中可以看到，初始化 parkBlockerOffset 时，会先通过反射获得 Thread 类的 parkBlocker 字段，然后通过 Unsafe 对象的 objectFieldOffset 方法获取到 parkBlocker 相对于 Thread 对象在内存中的起始地址的偏移量。\n\n##### park()\n```java\n    public static void park(Object blocker) {\n        // 获取当前线程\n        Thread t = Thread.currentThread();\n        // 设置当前线程的 blocker 对象\n        setBlocker(t, blocker);\n        // 通过Unsafe类挂起线程\n        UNSAFE.park(false, 0L);\n        // 挂起线程被唤醒后，需要将blocker清理掉\n        setBlocker(t, null);\n    }\n    \n    /* 其他重载版本 */\n    // 和 park(Object) 相比少了挂起前为线程设置 blocker、被唤醒后清理 blocker 的操作\n    public static void park() {\n        UNSAFE.park(false, 0L);\n    }\n    \n    // 指定一个挂起时间（相对于当前时间，单位为纳秒），时间到后自动被唤醒\n    public static void parkNanos(Object blocker, long nanos) {\n        if (nanos > 0) {\n            Thread t = Thread.currentThread();\n            setBlocker(t, blocker);\n            UNSAFE.park(false, nanos);\n            setBlocker(t, null);\n        }\n    }\n    \n    // 相对于 parkNanos(Object blocker, long nanos)，仅仅少了 blocker 相关操作\n    public static void parkNanos(long nanos) {\n        if (nanos > 0)\n            UNSAFE.park(false, nanos);\n    }\n    \n    // 指定一个挂起时间（绝对时间，单位为毫秒），时间到后自动被唤醒\n    public static void parkUntil(Object blocker, long deadline) {\n        Thread t = Thread.currentThread();\n        setBlocker(t, blocker);\n        UNSAFE.park(true, deadline);\n        setBlocker(t, null);\n    }\n    \n    // 相对于 parkUntil(Object blocker, long deadline)，仅仅少了 blocker 相关操作\n    public static void parkUntil(long deadline) {\n        UNSAFE.park(true, deadline);\n    }\n```\npark 主要功能：如果 permit 存在，那么将这个 permit 消耗掉，并且立即返回。如果许可不存在，那么挂起当前线程，直到以下任意事件发生：\n+ 其它线程以当前线程为参数，调用 unpark(Thread) 方法\n+ 其它线程通过 Thread.interrupt() 中断当前线程\n+ 该方法毫无理由的返回\n\n关于上面提到的最后一点，在 jdk 源码中的解释如下：\n```java\n    /**\n     * ··· ···\n     * <li>The call spuriously (that is, for no reason) returns.\n     * </ul>\n     *\n     * <p>This method does <em>not</em> report which of these caused the\n     * method to return. Callers should re-check the conditions which caused\n     * the thread to park in the first place. Callers may also determine,\n     * for example, the interrupt status of the thread upon return.\n     */\n```\n\n##### unpark\n```java\n    public static void unpark(Thread thread) {\n        if (thread != null)\n            UNSAFE.unpark(thread);\n    }\n```\n功能：设置线程许可可用。如果当前线程已经被 park 挂起，那么这个线程会被唤醒。如果线程没有被挂起，那么线程下次调用 park 不会被挂起。\n\n### 四、Java docs 中的示例用法：一个先进先出非重入锁框架\n```java\nclass FIFOMutex {\n    private final AtomicBoolean locked = new AtomicBoolean(false);\n    private final Queue<Thread> waiters\n        = new ConcurrentLinkedQueue<Thread>();\n\n    public void lock() {\n        boolean wasInterrupted = false;\n        Thread current = Thread.currentThread();\n        waiters.add(current);\n\n        // Block while not first in queue or cannot acquire lock\n        while (waiters.peek() != current ||\n            !locked.compareAndSet(false, true)) {\n            LockSupport.park(this);\n            if (Thread.interrupted()) // ignore interrupts while waiting\n                wasInterrupted = true;\n        }\n\n        waiters.remove();\n        if (wasInterrupted)          // reassert interrupt status on exit\n            current.interrupt();\n    }\n\n    public void unlock() {\n        locked.set(false);\n        LockSupport.unpark(waiters.peek());\n    }\n}\n```\n测试样例：\n```java\npublic class Test {\n\n    public static void main(String[] args) throws InterruptedException {\n        FIFOMutex mutex = new FIFOMutex();\n        MyThread a1 = new MyThread(\"a1\", mutex);\n        MyThread a2 = new MyThread(\"a2\", mutex);\n        MyThread a3 = new MyThread(\"a3\", mutex);\n\n        a1.start();\n        a2.start();\n        a3.start();\n\n        a1.join();\n        a2.join();\n        a3.join();\n\n        System.out.print(\"Finished\");\n    }\n}\n\nclass MyThread extends Thread {\n    private String name;\n    private FIFOMutex mutex;\n    public static int count;\n\n    public MyThread(String name, FIFOMutex mutex) {\n        this.name = name;\n        this.mutex = mutex;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            mutex.lock();\n            count++;\n            System.out.println(\"Thread: \" + name + \"-----count = \" + count);\n            mutex.unlock();\n        }\n    }\n}\n```\n\n### 五、比较\nLockSupport 中的 park 和 unpark、Object 中的 wait 和 notify 都可以实现线程的挂起与唤醒。当使用 wait 和 notify 时，它并不是直接对线程操作，而需要一个 Object 来进行线程的挂起和唤醒。在调用 wait 前，当前线程必须先获得该对象的监视器，被唤醒后需要重新获得该对象的监视器才能继续执行。而 LockSupport 直接面向 Thread，并对其进行挂起和唤醒，语义更加清晰，使用起来也更加方便。\n\nLockSupport 还可以避免出现 Thread.suspend 和 Thread.resume 的死锁问题。Thread.suspend 和 Thread.resume 是不推荐使用的，[官方的解释为](https://docs.oracle.com/javase/6/docs/technotes/guides/concurrency/threadPrimitiveDeprecation.html)：Thread.suspend 本质上是容易发生死锁的，因为它在挂起一个线程时并不会释放线程所占用的资源。如果目标线程在某个系统资源的监视器上持有锁，那么在调用 Thread.resume 恢复目标线程之前，其它任何线程都无法访问这个资源。如果恢复目标线程的线程在调用 Thread.resume 之前尝试锁定该系统资源的监视器，那么就会发生死锁。网上的很多文章都说 LockSupport 可以解决上诉问题，但是 LockSupport 中的 park 挂起线程时，也不会释放线程所占的资源。如下程序，将会发生死锁，因为在主线程调用 unpark 之前尝试获取 Resource 类对象的锁，而这时 minor 线程虽然被挂起，但并未释放所占资源，导致主线程获取锁失败，也被挂起，这样就会导致死锁（不知道是不是自己的理解问题，如下的程序并不能解决死锁问题）：\n```java\nimport java.util.concurrent.locks.LockSupport;\n\npublic class Test {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(() -> {\n            synchronized (Resource.class) {\n                Resource.print();\n                LockSupport.park();\n            }\n        }, \"minor\");\n        thread.start();\n\n        Thread.sleep(100);\n\n        synchronized (Resource.class) {\n            Resource.print();\n            LockSupport.unpark(thread);\n        }\n        System.out.println(\"end\");\n    }\n}\n\nclass Resource {\n    public static void print() {\n        System.out.println(Thread.currentThread().getName() + \"---print\");\n    }\n}\n```\n而如果将上面的 LockSupport 改为 wait 和 notify，则不会发生死锁，因为调用 wait 导致线程被挂起时，线程会释放所占资源，这样主线程就可获取锁，然后唤醒 minor 线程：\n```java\npublic class Test {\n\n    public static void main(String[] args) throws InterruptedException {\n        Thread thread = new Thread(() -> {\n            synchronized (Resource.class) {\n                Resource.print();\n                try {\n                    Resource.class.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }, \"minor\");\n        thread.start();\n\n        Thread.sleep(100);\n\n        synchronized (Resource.class) {\n            Resource.print();\n            Resource.class.notify();\n        }\n        System.out.println(\"end\");\n    }\n}\n\nclass Resource {\n    public static void print() {\n        System.out.println(Thread.currentThread().getName() + \"---print\");\n    }\n}\n\n/*\n    输出结果：\n        minor---print\n        main---print\n        end\n */\n```\n但是 LockSupport 却可以解决 Thread.suspend 的另一个问题，那就是如果在目标线程 Thread.suspend 发生之前调用 Thread.resume，那么目标线程如果没有其他的外界因素，将会一直被阻塞下去。wait 和 notify 也存在这样的问题，但是在 LockSupport 中，由于 permit 的存在，以及 park 和 unpark 的机制，park 和 unpark 的调用顺序就显得不那么重要了，即使先调用 unpark 再调用 park，程序依然可以正确运行，如下：\n```java\nimport java.util.concurrent.locks.LockSupport;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(\"start!\");\n        LockSupport.unpark(Thread.currentThread());\n        LockSupport.park();\n        System.out.println(\"end!\");\n    }\n}\n```\n**注意：如果线程是新建态（即刚新建了一个线程对象，还没有调用 start() 将它变为可运行态），这个时候调用 park 或 unpark 将不起作用。**这里最主要针对 unpark，因为 park 一定是在线程运行过程中调用，而 unpark 可能会在线程还是新建态时就调用了。如下程序，minor 线程将会永远被阻塞下去：\n```java\nimport java.util.concurrent.locks.LockSupport;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Thread minor = new Thread(() -> {\n            LockSupport.park();\n        }, \"minor\");\n\n        LockSupport.unpark(minor);\n        minor.start();\n    }\n}\n```\n\n参考：https://yq.aliyun.com/articles/493552#\nhttps://segmentfault.com/a/1190000015562456\n');
INSERT INTO `article` VALUES (14, 2, 2, '红黑树', '数据结构', '2019-06-21', 0, 0, '## 一、概述\n红黑树 (Red-Black Tree) 是一种特殊的二叉查找树，这意味着它满足二叉查找树的特征：任意一个节点的键值大于其左孩子的键值，且小于等于其右孩子的键值。除了具备二叉查找树的所有特性外，红黑树还包含了许多额外的信息。红黑树的每一个节点上都有一个存储位来表示节点的颜色信息，要么是红色，要么是黑色。一颗红黑树必定满足以下五个特征：\n1. 每个节点要么是红色，要么是黑色\n2. 根节点是黑色\n3. 每个叶子节点的两个空节点是黑色的（后面称之为 NULL 节点）\n4. 每个红色节点的两个子节点都是黑色的（根到每个叶子节点的所有路径上不能有两个连续的红色节点）\n5. 对于任意一个节点而言，它到叶节点的每一条路径上都包含相同数目的黑色节点\n\n<!-- more -->\n\n<center><img src=\"https://debugxw.github.io/img/rbt/rbt_ex.png\" width=\"30%\" height=\"30%\" /></center>\n\n上图所示的红黑树的黑高 BH = 3。虽然红黑树不像 AVL 树一样，在高度上永远保持绝对的平衡，但是红黑树会保持相对平衡即 BH(left) == BH(right)，也就是说任意一个节点到叶子节点的最长路径不会超过最短路径长度的二倍（不包括最后的 NULL 节点）。\n**定理：**有 N 个节点的红黑树，树的最大高度是 2log(N+1)。\n\n## 二、插入\n当向一颗红黑树中插入一个节点后，就有可能破坏红黑树的平衡，这时就需要做相应的调整，使得红黑树依旧满足上面所说的五个特性。插入一个节点时，首先按照平衡二叉树的插入规则将新节点添加到相应的位置，然后再进行调整。\n\n首先我们想一下，新插入的节点应该是红色的还是黑色的呢？答案是红色。因为如果新插入的节点是黑色，则一定会违背上面的第五个特性，而如果新节点是红色的，则有可能违背第四个特性，也有可能不违背上面五个特性之中的任意一个，即插入新节点之后树还是平衡的。这就意味着我们调整时，如果新节点是红色的，我们处理的情况就会少一些。接下来，就是如何调整这棵树，努力使得它满足以上的五个特性，那么它就又重新变成了一颗正统的红黑树了！！！\n\n为了方便讲述，进行如下规定（下图插入 X 后需要调整）：\n+ 新插入的节点（当前节点）为 X，父节点为 P，祖父节点为 G，叔叔节点为 Y\n+ A3 表示该子树的黑高 BH = 3，B3 表示该子树的黑高 BH = 3，C2 表示...\n\n<center><img src=\"../../../../img/rbt/rbt_ex.png\" width=\"30%\" height=\"30%\" /></center>\n\n#### 1、无需调整\n插入节点后，有两种情况无需调整：\n+ X 为根节点，这时只需将根节点由红染黑即可。注意：如果在后续的回溯过程中 X 变为根节点，也属于这种情况\n+ 父节点 P 为黑色，则当前树满足上面的所有特性，无需调整\n\n#### 2、需要调整\n插入新节点后，有六种情况需要调整，而前三种和后三种是两两对称的：\n+ P 为 G 的左子树：\n  + a：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G\n  <center><img src=\"../../../../img/rbt/rbt_a.png\" width=\"60%\" height=\"60%\" /></center>\n  + b：Y 为黑，X 为右子树；左旋 P，当前节点 X 变为 P（即把 P 当做新插入的节点），转化为 c（如果G 的右子树为空，即 Y 为空，那么 Y 就是空的黑色叶子节点）\n  <center><img src=\"../../../../img/rbt/rbt_b.png\" width=\"60%\" height=\"60%\" /></center>\n  + c：Y 为黑，X 为左子树；P 染黑，G 染红，右旋 G，结束\n  <center><img src=\"../../../../img/rbt/rbt_c.png\" width=\"60%\" height=\"60%\" /></center>\n+ P 为 G 的右子树：\n  + d：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G\n  + e：Y 为黑，X 为左子树；右旋 P，当前节点 X 变为 P，转化为 f\n  + f：Y 为黑，X 为右子树；P 染黑，G 染红，左旋 G，结束\n\n可以看到，其实上面的 a 和 d 两种情况的调整操作是一样的，而这六种情况的核心思路都是：**将红色节点移动到根节点，然后将根节点染黑。**\n#### 3、构建红黑树\n假设要插入的节点依次为 [12, 1, 9, 0, 3, 5, 4]，则构建红黑树的过程如下（这里省略了 NULL 节点）：\n\n<center><img src=\"../../../../img/rbt/rbt_insert.png\" width=\"90%\" height=\"90%\" /></center>\n\n#### AVL 插入 VS RBT 插入\n+ 插入元素都是 BST 的插入，区别在于调整\n+ 旋转次数：AVL 和 RBT 都是 O(1)\n+ 指针回溯次数，最好：\n  + 很早就遇到单旋或双旋的情况，为 O(1)\n  + 很早就遇到 b、c 或者 e、f 的情况，为 O(1)\n+ 指针回溯次数，最坏：\n  + 回溯到根节点才发现平衡因子大于 1 或小于 -1，为 O(logN)\n  + 不断执行 a 情况，直到根节点，**但每次向上回溯两层，**为 O(logN / 2)\n+ 插入效率：RBT 略好于 AVL\n+ 查询效率：AVL 略好于 RBT\n\n## 三、删除\n对于一棵普通的二叉排序树来说，删除的节点情况可以分为三种：\n1. 待删除节点为叶子节点\n2. 待删除节点只有左子树或只有右子树\n3. 待删除节点既有左子树又有右子树\n\n对于情况 3，要删除既有左子树又有右子树的节点，我们首先要找到该节点的先驱节点或后继节点，然后用先驱节点或后继节点替换该节点，最后按 1 或 2 中的方法删除后继节点即可。这样情况 3 就可以转换为情况 1 或 2。所以我们要删除的节点类型从大的方面来说，就只有两种。\n同样，对于红黑树来说，我们要删除的节点类型大体来讲也只有两种。\n\n#### 1、待删节点只有左子树或只有右子树\n假设待删除节点为 D，D 的父节点为 P，P 的另一个孩子节点为 S，S 的左右子树分别为 SL 和 SR。\n在这种情况下，待删节点 D 不可能为红色（如果 D 为红色，那么一定会违背红黑树的特性 4 或 5，所以 D 只能为黑色）。D 为黑色那么只会出现以下两种情况：\n\n<center><img src=\"../../../../img/rbt/rbt_delete_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n这两种情况的处理方式是一样的，即将 D 的左孩子或右孩子的颜色改成黑色，并用 D 的左孩子或右孩子替换 D，再将 D 删除即可（因为删除 D 以后，以 D 为根的子树上少了一个黑节点，所以要将 D 的孩子由红色变成黑色以保持红黑树的性质）。\n\n#### 2、待删除节点为叶子节点\n**叶子节点为红色**\n如果待删除节点为叶子节点且为红色，那么直接将该节点删除即可（因为删除一个红色叶子节点并不会违反红黑树的任何一个特性）。\n\n**叶子节点为黑色**\n这也是最复杂的一种情况，在调整的过程中，待删除节点 D 可能会向上回溯，回溯之后再看 D 是下面哪种情况进行调整，**直到 D 为红色或者 D 为根节点，这时，将刚开始的待删除节点删除，将此时 D 指向的节点染黑，调整结束**（即先进行调整，调整完成后，再来删除 D）。\n\n**情况1-1**\nD 是 P 的左孩子，且 S 为红色：**P 变成红色，S 变成黑色，左旋 P**（如下图，这里省略了 NULL 节点）。此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_1_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况1-2**\nD 是 P 的右孩子，且 S 为红色：**P 变成红色，S 变成黑色，右旋 P。**此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。（这种情况和情况1-1对称）\n\n**情况2-1**\nD 是 P 的左孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（如下图，在这个例子中，SL、SR 只能为 NULL 节点，D 回溯至 P 之后发现 P 为根节点，这时直接将 P 染黑，删除 D 即可。其中黄色代表红黑均可。）\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_2_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况2-2**\nD 是 P 的右孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（这种情况和情况2-1对称）\n\n**情况3-1**\nD 是 P 的左孩子，且 S 为黑色，SL 为红色，SR 为黑色，P 红黑均可：**SL 染黑，S 染红，右旋 S**（这时就转换为了情况 4-1）。\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_3_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况3-2**\nD 是 P 的右孩子，且 S 为黑色，SL 为黑色，SR 为红色，P 红黑均可：**LR 染黑，S 染红，左旋 S**（这时就转换为了情况 4-2，和情况3-1对称）。\n\n**情况4-1**\nD 是 P 的左孩子，且 S 为黑色，SR 为红色，SL 红黑均可（如果 SL 为黑色，那么一定为 NULL 节点）：**将 S 染为 P 的颜色，P 和 SR 染黑，左旋 P**，此时 D 回溯至根节点。（在下面这个例子中，指针回溯之后，发现指针指向根节点，这时直接将根节点 S 染为黑色，删除 D 即可）\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_4_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况4-2**\nD 是 P 的右孩子，且 S 为黑色，SL 为红色，SR 红黑均可：**将 S 染为 P 的颜色，P 和 SL 染黑，左旋 P**，此时 D 回溯至根节点（和情况 4-1 对称）。\n\n#### 3、删除红黑树样例\n\n<center><img src=\"../../../../img/rbt/rbt_delete_3.png\" width=\"90%\" height=\"90%\" /></center>\n\n## 四、AVL 树和 RBT 树的应用\n+ 红黑树\n  + 广泛用于 c++ 的 STL 中，map 和 set 都是用红黑树实现的\n  + 著名的 Linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一棵红黑树上，每个虚拟地址区域都对应一个红黑树节点，左指针指向相邻的低地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间\n  + IO 多路复用 epoll 的实现采用红黑树组织管理 sockfd，以支持快速的增删改查\n  + ngnix 中用红黑树管理 timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器\n  + JDK1.8 中 TreeMap、HashMap、ConcurrentHashMap 的实现采用了红黑树\n+ 虽然 AVL 树的查找效率很高，但由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多\n  + Windows 对进程地址空间的管理用到了 AVL 树\n  + Windows NT 内核中广泛存在\n\n## 五、TreeMap 和 TreeSet\n### TreeMap\nTreeMap 是 java 中用来存储可排序键值对的一种容器，其内部使用的数据结构就是红黑树。每个红黑树节点存储一个 key-value 键值对，并根据 key 进行排序，排序的方式有两种：\n+ 自然排序：此时，所有的 key 必须实现 Comparable 接口，用于比较两个 key 的大小\n+ 定制排序：定义 TreeMap 时，新建一个 Comparator 对象，该对象用于比较任意两个 key 的大小\n\n注意：如果使用自定义的类作为 TreeMap 中的 key 和 value，且想让 TreeMap 能够良好的工作，**则必须重写自定义类中的 equals 方法。**例如在 containsValue 中比较两个 value 是否相同就用到了 valEquals() 方法，而 valEquals() 方法则用到了对象的 equals 方法，源码如下：\n```java\n    public boolean containsValue(Object value) {\n        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e))\n            if (valEquals(value, e.value))\n                return true;\n        return false;\n    }\n    \n    static final boolean valEquals(Object o1, Object o2) {\n        return (o1==null ? o2==null : o1.equals(o2));\n    }\n```\n\n### TreeSet\nTreeSet 是 java 中用来存储不能重复且有序的数据的一种容器。但在本质上，TreeSet 其实是用 TreeMap 来存储数据的。在 TreeSet 的源码中，有如下两个成员：\n```java\n    /**\n     * The backing map.\n     */\n    private transient NavigableMap<E,Object> m;\n\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n```\n这里的 NavigableMap 只是一个接口，但在构造 TreeSet 的时候会将 m 初始化为一个 TreeMap，这个 TreeMap 就是用来存储数据的容器。TreeSet 将所有的数据存储在 m 的 key 中，因为 TreeMap 中的 key 是唯一的且有序，所以也就达到了 TreeSet 存储不重复元素且有序的目的。在向 TreeSet 中添加一个元素时，实际上是调用了 TreeMap 的 put() 方法：\n```java\n    public boolean add(E e) {\n        return m.put(e, PRESENT)==null;\n    }\n```\n可以看到，在添加元素时，TreeSet 将元素作为 key 添加到 m 中，而 value 则放入一个 Object 常量（本质上 value 没什么卵用），也就是说 m 中存储的所有键值对的 key 都不相同，而 value 都相同。\nTreeSet 中的其它方法，其实也都是直接调用了 TreeMap 中的方法，例如：\n```java\n    public boolean remove(Object o) {\n        return m.remove(o)==PRESENT;\n    }\n    \n    public boolean contains(Object o) {\n        return m.containsKey(o);\n    }\n    \n    public int size() {\n        return m.size();\n    }\n```\n\n## 六、源代码（java 实现）\n由于本人太菜，写不出红黑树的代码，所以就把 TreeMap 中的部分源码给扣了下来。\n```java\nimport java.util.Comparator;\n\npublic class RBTree<K, V> {\n\n    private static final boolean RED = false;\n    private static final boolean BLACK = true;\n\n    private Entry<K, V> root;\n\n    private final Comparator<? super K> comparator;\n\n    public RBTree() {\n        comparator = null;\n    }\n\n    public RBTree(Comparator<? super K> comparator) {\n        this.comparator = comparator;\n    }\n\n    static final class Entry<K, V> {\n        K key;\n        V value;\n        Entry<K, V> left;\n        Entry<K, V> right;\n        Entry<K, V> parent;\n        boolean color = BLACK;\n\n        Entry(K key, V value, Entry<K, V> parent) {\n            this.key = key;\n            this.value = value;\n            this.parent = parent;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n\n        public V setValue(V value) {\n            V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof Entry))\n                return false;\n            Entry<?, ?> e = (Entry<?, ?>) o;\n\n            return valEquals(key, e.getKey()) && valEquals(value, e.getValue());\n        }\n\n        public int hashCode() {\n            int keyHash = (key == null ? 0 : key.hashCode());\n            int valueHash = (value == null ? 0 : value.hashCode());\n            return keyHash ^ valueHash;\n        }\n\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n\n    static final boolean valEquals(Object o1, Object o2) {\n        return (o1 == null ? o2 == null : o1.equals(o2));\n    }\n\n    public V put(K key, V value) {\n        Entry<K, V> t = root;\n        if (t == null) {\n            root = new Entry<>(key, value, null);\n            return null;\n        }\n        int cmp;\n        Entry<K, V> parent;\n        // split comparator and comparable paths\n        Comparator<? super K> cpr = comparator;\n        if (cpr != null) {\n            do {\n                parent = t;\n                cmp = cpr.compare(key, t.key);\n                if (cmp < 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            } while (t != null);\n        } else {\n            if (key == null)\n                throw new NullPointerException();\n            @SuppressWarnings(\"unchecked\")\n            Comparable<? super K> k = (Comparable<? super K>) key;\n            do {\n                parent = t;\n                cmp = k.compareTo(t.key);\n                if (cmp < 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            } while (t != null);\n        }\n        Entry<K, V> e = new Entry<>(key, value, parent);\n        if (cmp < 0)\n            parent.left = e;\n        else\n            parent.right = e;\n        fixAfterInsertion(e);\n        return null;\n    }\n\n    private void fixAfterInsertion(Entry<K, V> x) {\n        x.color = RED;\n\n        while (x != null && x != root && x.parent.color == RED) {\n            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n                Entry<K, V> y = rightOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == rightOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateLeft(x);\n                    }\n                    setColor(parentOf(x), BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateRight(parentOf(parentOf(x)));\n                }\n            } else {\n                Entry<K, V> y = leftOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == leftOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateRight(x);\n                    }\n                    setColor(parentOf(x), BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateLeft(parentOf(parentOf(x)));\n                }\n            }\n        }\n        root.color = BLACK;\n    }\n\n    private static <K, V> boolean colorOf(Entry<K, V> p) {\n        return (p == null ? BLACK : p.color);\n    }\n\n    private static <K, V> Entry<K, V> parentOf(Entry<K, V> p) {\n        return (p == null ? null : p.parent);\n    }\n\n    private static <K, V> void setColor(Entry<K, V> p, boolean c) {\n        if (p != null)\n            p.color = c;\n    }\n\n    private static <K, V> Entry<K, V> leftOf(Entry<K, V> p) {\n        return (p == null) ? null : p.left;\n    }\n\n    private static <K, V> Entry<K, V> rightOf(Entry<K, V> p) {\n        return (p == null) ? null : p.right;\n    }\n\n    private void rotateLeft(Entry<K, V> p) {\n        if (p != null) {\n            Entry<K, V> r = p.right;\n            p.right = r.left;\n            if (r.left != null)\n                r.left.parent = p;\n            r.parent = p.parent;\n            if (p.parent == null)\n                root = r;\n            else if (p.parent.left == p)\n                p.parent.left = r;\n            else\n                p.parent.right = r;\n            r.left = p;\n            p.parent = r;\n        }\n    }\n\n    private void rotateRight(Entry<K, V> p) {\n        if (p != null) {\n            Entry<K, V> l = p.left;\n            p.left = l.right;\n            if (l.right != null) l.right.parent = p;\n            l.parent = p.parent;\n            if (p.parent == null)\n                root = l;\n            else if (p.parent.right == p)\n                p.parent.right = l;\n            else p.parent.left = l;\n            l.right = p;\n            p.parent = l;\n        }\n    }\n\n    public V remove(Object key) {\n        Entry<K, V> p = getEntry(key);\n        if (p == null)\n            return null;\n\n        V oldValue = p.value;\n        deleteEntry(p);\n        return oldValue;\n    }\n\n    final Entry<K, V> getEntry(Object key) {\n        // Offload comparator-based version for sake of performance\n        if (comparator != null)\n            return getEntryUsingComparator(key);\n        if (key == null)\n            throw new NullPointerException();\n        @SuppressWarnings(\"unchecked\")\n        Comparable<? super K> k = (Comparable<? super K>) key;\n        Entry<K, V> p = root;\n        while (p != null) {\n            int cmp = k.compareTo(p.key);\n            if (cmp < 0)\n                p = p.left;\n            else if (cmp > 0)\n                p = p.right;\n            else\n                return p;\n        }\n        return null;\n    }\n\n    final Entry<K, V> getEntryUsingComparator(Object key) {\n        @SuppressWarnings(\"unchecked\")\n        K k = (K) key;\n        Comparator<? super K> cpr = comparator;\n        if (cpr != null) {\n            Entry<K, V> p = root;\n            while (p != null) {\n                int cmp = cpr.compare(k, p.key);\n                if (cmp < 0)\n                    p = p.left;\n                else if (cmp > 0)\n                    p = p.right;\n                else\n                    return p;\n            }\n        }\n        return null;\n    }\n\n    private void deleteEntry(Entry<K, V> p) {\n        // 找到直接后继节点\n        if (p.left != null && p.right != null) {\n            Entry<K, V> s = successor(p);\n            p.key = s.key;\n            p.value = s.value;\n            p = s;\n        }\n\n        // Start fixup at replacement node, if it exists.\n        Entry<K, V> replacement = (p.left != null ? p.left : p.right);\n\n        // 只有一个叶子节点的情况\n        if (replacement != null) {\n            // Link replacement to parent\n            replacement.parent = p.parent;\n            if (p.parent == null)\n                root = replacement;\n            else if (p == p.parent.left)\n                p.parent.left = replacement;\n            else\n                p.parent.right = replacement;\n\n            // Null out links so they are OK to use by fixAfterDeletion.\n            p.left = p.right = p.parent = null;\n\n            // 待删除节点为黑色，且只有一个红色孩子节点\n            if (p.color == BLACK)\n                fixAfterDeletion(replacement);\n        } else if (p.parent == null) { // 只有根节点，直接删除\n            root = null;\n        } else { // 删除叶子节点\n            if (p.color == BLACK)\n                fixAfterDeletion(p);\n\n            if (p.parent != null) {\n                if (p == p.parent.left)\n                    p.parent.left = null;\n                else if (p == p.parent.right)\n                    p.parent.right = null;\n                p.parent = null;\n            }\n        }\n    }\n\n    static <K, V> Entry<K, V> successor(Entry<K, V> t) {\n        if (t == null)\n            return null;\n        else if (t.right != null) {\n            Entry<K, V> p = t.right;\n            while (p.left != null)\n                p = p.left;\n            return p;\n        } else {\n            Entry<K, V> p = t.parent;\n            Entry<K, V> ch = t;\n            while (p != null && ch == p.right) {\n                ch = p;\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n\n    private void fixAfterDeletion(Entry<K, V> x) {\n        while (x != root && colorOf(x) == BLACK) {\n            if (x == leftOf(parentOf(x))) {\n                Entry<K, V> sib = rightOf(parentOf(x));\n\n                // 情况 1-1\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateLeft(parentOf(x));\n                    sib = rightOf(parentOf(x));\n                }\n\n                // 情况 2-1\n                if (colorOf(leftOf(sib)) == BLACK &&\n                    colorOf(rightOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    // 情况 3-1\n                    if (colorOf(rightOf(sib)) == BLACK) {\n                        setColor(leftOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateRight(sib);\n                        sib = rightOf(parentOf(x));\n                    }\n                    // 情况 4-1\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(rightOf(sib), BLACK);\n                    rotateLeft(parentOf(x));\n                    x = root;\n                }\n            } else { // 和上面对称\n                Entry<K, V> sib = leftOf(parentOf(x));\n\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateRight(parentOf(x));\n                    sib = leftOf(parentOf(x));\n                }\n\n                if (colorOf(rightOf(sib)) == BLACK &&\n                    colorOf(leftOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    if (colorOf(leftOf(sib)) == BLACK) {\n                        setColor(rightOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateLeft(sib);\n                        sib = leftOf(parentOf(x));\n                    }\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(leftOf(sib), BLACK);\n                    rotateRight(parentOf(x));\n                    x = root;\n                }\n            }\n        }\n\n        setColor(x, BLACK);\n    }\n\n    final Entry<K,V> getFirstEntry() {\n        Entry<K,V> p = root;\n        if (p != null)\n            while (p.left != null)\n                p = p.left;\n        return p;\n    }\n\n    public boolean containsValue(Object value) {\n        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e)) {\n            if (valEquals(value, e.value))\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n参考：https://www.bilibili.com/video/av23890827/?p=10\nhttps://www.cnblogs.com/qingergege/p/7351659.html\n');
INSERT INTO `article` VALUES (15, 2, 2, '数据结构', '数据结构', '2019-06-21', 0, 0, '## 一、概述\n红黑树 (Red-Black Tree) 是一种特殊的二叉查找树，这意味着它满足二叉查找树的特征：任意一个节点的键值大于其左孩子的键值，且小于等于其右孩子的键值。除了具备二叉查找树的所有特性外，红黑树还包含了许多额外的信息。红黑树的每一个节点上都有一个存储位来表示节点的颜色信息，要么是红色，要么是黑色。一颗红黑树必定满足以下五个特征：\n1. 每个节点要么是红色，要么是黑色\n2. 根节点是黑色\n3. 每个叶子节点的两个空节点是黑色的（后面称之为 NULL 节点）\n4. 每个红色节点的两个子节点都是黑色的（根到每个叶子节点的所有路径上不能有两个连续的红色节点）\n5. 对于任意一个节点而言，它到叶节点的每一条路径上都包含相同数目的黑色节点\n\n<!-- more -->\n\n<center><img src=\"https://debugxw.github.io/img/rbt/rbt_ex.png\" width=\"30%\" height=\"30%\" /></center>\n\n上图所示的红黑树的黑高 BH = 3。虽然红黑树不像 AVL 树一样，在高度上永远保持绝对的平衡，但是红黑树会保持相对平衡即 BH(left) == BH(right)，也就是说任意一个节点到叶子节点的最长路径不会超过最短路径长度的二倍（不包括最后的 NULL 节点）。\n**定理：**有 N 个节点的红黑树，树的最大高度是 2log(N+1)。\n\n## 二、插入\n当向一颗红黑树中插入一个节点后，就有可能破坏红黑树的平衡，这时就需要做相应的调整，使得红黑树依旧满足上面所说的五个特性。插入一个节点时，首先按照平衡二叉树的插入规则将新节点添加到相应的位置，然后再进行调整。\n\n首先我们想一下，新插入的节点应该是红色的还是黑色的呢？答案是红色。因为如果新插入的节点是黑色，则一定会违背上面的第五个特性，而如果新节点是红色的，则有可能违背第四个特性，也有可能不违背上面五个特性之中的任意一个，即插入新节点之后树还是平衡的。这就意味着我们调整时，如果新节点是红色的，我们处理的情况就会少一些。接下来，就是如何调整这棵树，努力使得它满足以上的五个特性，那么它就又重新变成了一颗正统的红黑树了！！！\n\n为了方便讲述，进行如下规定（下图插入 X 后需要调整）：\n+ 新插入的节点（当前节点）为 X，父节点为 P，祖父节点为 G，叔叔节点为 Y\n+ A3 表示该子树的黑高 BH = 3，B3 表示该子树的黑高 BH = 3，C2 表示...\n\n<center><img src=\"../../../../img/rbt/rbt_ex.png\" width=\"30%\" height=\"30%\" /></center>\n\n#### 1、无需调整\n插入节点后，有两种情况无需调整：\n+ X 为根节点，这时只需将根节点由红染黑即可。注意：如果在后续的回溯过程中 X 变为根节点，也属于这种情况\n+ 父节点 P 为黑色，则当前树满足上面的所有特性，无需调整\n\n#### 2、需要调整\n插入新节点后，有六种情况需要调整，而前三种和后三种是两两对称的：\n+ P 为 G 的左子树：\n  + a：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G\n  <center><img src=\"../../../../img/rbt/rbt_a.png\" width=\"60%\" height=\"60%\" /></center>\n  + b：Y 为黑，X 为右子树；左旋 P，当前节点 X 变为 P（即把 P 当做新插入的节点），转化为 c（如果G 的右子树为空，即 Y 为空，那么 Y 就是空的黑色叶子节点）\n  <center><img src=\"../../../../img/rbt/rbt_b.png\" width=\"60%\" height=\"60%\" /></center>\n  + c：Y 为黑，X 为左子树；P 染黑，G 染红，右旋 G，结束\n  <center><img src=\"../../../../img/rbt/rbt_c.png\" width=\"60%\" height=\"60%\" /></center>\n+ P 为 G 的右子树：\n  + d：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G\n  + e：Y 为黑，X 为左子树；右旋 P，当前节点 X 变为 P，转化为 f\n  + f：Y 为黑，X 为右子树；P 染黑，G 染红，左旋 G，结束\n\n可以看到，其实上面的 a 和 d 两种情况的调整操作是一样的，而这六种情况的核心思路都是：**将红色节点移动到根节点，然后将根节点染黑。**\n#### 3、构建红黑树\n假设要插入的节点依次为 [12, 1, 9, 0, 3, 5, 4]，则构建红黑树的过程如下（这里省略了 NULL 节点）：\n\n<center><img src=\"../../../../img/rbt/rbt_insert.png\" width=\"90%\" height=\"90%\" /></center>\n\n#### AVL 插入 VS RBT 插入\n+ 插入元素都是 BST 的插入，区别在于调整\n+ 旋转次数：AVL 和 RBT 都是 O(1)\n+ 指针回溯次数，最好：\n  + 很早就遇到单旋或双旋的情况，为 O(1)\n  + 很早就遇到 b、c 或者 e、f 的情况，为 O(1)\n+ 指针回溯次数，最坏：\n  + 回溯到根节点才发现平衡因子大于 1 或小于 -1，为 O(logN)\n  + 不断执行 a 情况，直到根节点，**但每次向上回溯两层，**为 O(logN / 2)\n+ 插入效率：RBT 略好于 AVL\n+ 查询效率：AVL 略好于 RBT\n\n## 三、删除\n对于一棵普通的二叉排序树来说，删除的节点情况可以分为三种：\n1. 待删除节点为叶子节点\n2. 待删除节点只有左子树或只有右子树\n3. 待删除节点既有左子树又有右子树\n\n对于情况 3，要删除既有左子树又有右子树的节点，我们首先要找到该节点的先驱节点或后继节点，然后用先驱节点或后继节点替换该节点，最后按 1 或 2 中的方法删除后继节点即可。这样情况 3 就可以转换为情况 1 或 2。所以我们要删除的节点类型从大的方面来说，就只有两种。\n同样，对于红黑树来说，我们要删除的节点类型大体来讲也只有两种。\n\n#### 1、待删节点只有左子树或只有右子树\n假设待删除节点为 D，D 的父节点为 P，P 的另一个孩子节点为 S，S 的左右子树分别为 SL 和 SR。\n在这种情况下，待删节点 D 不可能为红色（如果 D 为红色，那么一定会违背红黑树的特性 4 或 5，所以 D 只能为黑色）。D 为黑色那么只会出现以下两种情况：\n\n<center><img src=\"../../../../img/rbt/rbt_delete_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n这两种情况的处理方式是一样的，即将 D 的左孩子或右孩子的颜色改成黑色，并用 D 的左孩子或右孩子替换 D，再将 D 删除即可（因为删除 D 以后，以 D 为根的子树上少了一个黑节点，所以要将 D 的孩子由红色变成黑色以保持红黑树的性质）。\n\n#### 2、待删除节点为叶子节点\n**叶子节点为红色**\n如果待删除节点为叶子节点且为红色，那么直接将该节点删除即可（因为删除一个红色叶子节点并不会违反红黑树的任何一个特性）。\n\n**叶子节点为黑色**\n这也是最复杂的一种情况，在调整的过程中，待删除节点 D 可能会向上回溯，回溯之后再看 D 是下面哪种情况进行调整，**直到 D 为红色或者 D 为根节点，这时，将刚开始的待删除节点删除，将此时 D 指向的节点染黑，调整结束**（即先进行调整，调整完成后，再来删除 D）。\n\n**情况1-1**\nD 是 P 的左孩子，且 S 为红色：**P 变成红色，S 变成黑色，左旋 P**（如下图，这里省略了 NULL 节点）。此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_1_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况1-2**\nD 是 P 的右孩子，且 S 为红色：**P 变成红色，S 变成黑色，右旋 P。**此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。（这种情况和情况1-1对称）\n\n**情况2-1**\nD 是 P 的左孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（如下图，在这个例子中，SL、SR 只能为 NULL 节点，D 回溯至 P 之后发现 P 为根节点，这时直接将 P 染黑，删除 D 即可。其中黄色代表红黑均可。）\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_2_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况2-2**\nD 是 P 的右孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（这种情况和情况2-1对称）\n\n**情况3-1**\nD 是 P 的左孩子，且 S 为黑色，SL 为红色，SR 为黑色，P 红黑均可：**SL 染黑，S 染红，右旋 S**（这时就转换为了情况 4-1）。\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_3_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况3-2**\nD 是 P 的右孩子，且 S 为黑色，SL 为黑色，SR 为红色，P 红黑均可：**LR 染黑，S 染红，左旋 S**（这时就转换为了情况 4-2，和情况3-1对称）。\n\n**情况4-1**\nD 是 P 的左孩子，且 S 为黑色，SR 为红色，SL 红黑均可（如果 SL 为黑色，那么一定为 NULL 节点）：**将 S 染为 P 的颜色，P 和 SR 染黑，左旋 P**，此时 D 回溯至根节点。（在下面这个例子中，指针回溯之后，发现指针指向根节点，这时直接将根节点 S 染为黑色，删除 D 即可）\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_4_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况4-2**\nD 是 P 的右孩子，且 S 为黑色，SL 为红色，SR 红黑均可：**将 S 染为 P 的颜色，P 和 SL 染黑，左旋 P**，此时 D 回溯至根节点（和情况 4-1 对称）。\n\n#### 3、删除红黑树样例\n\n<center><img src=\"../../../../img/rbt/rbt_delete_3.png\" width=\"90%\" height=\"90%\" /></center>\n\n## 四、AVL 树和 RBT 树的应用\n+ 红黑树\n  + 广泛用于 c++ 的 STL 中，map 和 set 都是用红黑树实现的\n  + 著名的 Linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一棵红黑树上，每个虚拟地址区域都对应一个红黑树节点，左指针指向相邻的低地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间\n  + IO 多路复用 epoll 的实现采用红黑树组织管理 sockfd，以支持快速的增删改查\n  + ngnix 中用红黑树管理 timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器\n  + JDK1.8 中 TreeMap、HashMap、ConcurrentHashMap 的实现采用了红黑树\n+ 虽然 AVL 树的查找效率很高，但由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多\n  + Windows 对进程地址空间的管理用到了 AVL 树\n  + Windows NT 内核中广泛存在\n\n## 五、TreeMap 和 TreeSet\n### TreeMap\nTreeMap 是 java 中用来存储可排序键值对的一种容器，其内部使用的数据结构就是红黑树。每个红黑树节点存储一个 key-value 键值对，并根据 key 进行排序，排序的方式有两种：\n+ 自然排序：此时，所有的 key 必须实现 Comparable 接口，用于比较两个 key 的大小\n+ 定制排序：定义 TreeMap 时，新建一个 Comparator 对象，该对象用于比较任意两个 key 的大小\n\n注意：如果使用自定义的类作为 TreeMap 中的 key 和 value，且想让 TreeMap 能够良好的工作，**则必须重写自定义类中的 equals 方法。**例如在 containsValue 中比较两个 value 是否相同就用到了 valEquals() 方法，而 valEquals() 方法则用到了对象的 equals 方法，源码如下：\n```java\n    public boolean containsValue(Object value) {\n        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e))\n            if (valEquals(value, e.value))\n                return true;\n        return false;\n    }\n    \n    static final boolean valEquals(Object o1, Object o2) {\n        return (o1==null ? o2==null : o1.equals(o2));\n    }\n```\n\n### TreeSet\nTreeSet 是 java 中用来存储不能重复且有序的数据的一种容器。但在本质上，TreeSet 其实是用 TreeMap 来存储数据的。在 TreeSet 的源码中，有如下两个成员：\n```java\n    /**\n     * The backing map.\n     */\n    private transient NavigableMap<E,Object> m;\n\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n```\n这里的 NavigableMap 只是一个接口，但在构造 TreeSet 的时候会将 m 初始化为一个 TreeMap，这个 TreeMap 就是用来存储数据的容器。TreeSet 将所有的数据存储在 m 的 key 中，因为 TreeMap 中的 key 是唯一的且有序，所以也就达到了 TreeSet 存储不重复元素且有序的目的。在向 TreeSet 中添加一个元素时，实际上是调用了 TreeMap 的 put() 方法：\n```java\n    public boolean add(E e) {\n        return m.put(e, PRESENT)==null;\n    }\n```\n可以看到，在添加元素时，TreeSet 将元素作为 key 添加到 m 中，而 value 则放入一个 Object 常量（本质上 value 没什么卵用），也就是说 m 中存储的所有键值对的 key 都不相同，而 value 都相同。\nTreeSet 中的其它方法，其实也都是直接调用了 TreeMap 中的方法，例如：\n```java\n    public boolean remove(Object o) {\n        return m.remove(o)==PRESENT;\n    }\n    \n    public boolean contains(Object o) {\n        return m.containsKey(o);\n    }\n    \n    public int size() {\n        return m.size();\n    }\n```\n\n## 六、源代码（java 实现）\n由于本人太菜，写不出红黑树的代码，所以就把 TreeMap 中的部分源码给扣了下来。\n```java\nimport java.util.Comparator;\n\npublic class RBTree<K, V> {\n\n    private static final boolean RED = false;\n    private static final boolean BLACK = true;\n\n    private Entry<K, V> root;\n\n    private final Comparator<? super K> comparator;\n\n    public RBTree() {\n        comparator = null;\n    }\n\n    public RBTree(Comparator<? super K> comparator) {\n        this.comparator = comparator;\n    }\n\n    static final class Entry<K, V> {\n        K key;\n        V value;\n        Entry<K, V> left;\n        Entry<K, V> right;\n        Entry<K, V> parent;\n        boolean color = BLACK;\n\n        Entry(K key, V value, Entry<K, V> parent) {\n            this.key = key;\n            this.value = value;\n            this.parent = parent;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n\n        public V setValue(V value) {\n            V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof Entry))\n                return false;\n            Entry<?, ?> e = (Entry<?, ?>) o;\n\n            return valEquals(key, e.getKey()) && valEquals(value, e.getValue());\n        }\n\n        public int hashCode() {\n            int keyHash = (key == null ? 0 : key.hashCode());\n            int valueHash = (value == null ? 0 : value.hashCode());\n            return keyHash ^ valueHash;\n        }\n\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n\n    static final boolean valEquals(Object o1, Object o2) {\n        return (o1 == null ? o2 == null : o1.equals(o2));\n    }\n\n    public V put(K key, V value) {\n        Entry<K, V> t = root;\n        if (t == null) {\n            root = new Entry<>(key, value, null);\n            return null;\n        }\n        int cmp;\n        Entry<K, V> parent;\n        // split comparator and comparable paths\n        Comparator<? super K> cpr = comparator;\n        if (cpr != null) {\n            do {\n                parent = t;\n                cmp = cpr.compare(key, t.key);\n                if (cmp < 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            } while (t != null);\n        } else {\n            if (key == null)\n                throw new NullPointerException();\n            @SuppressWarnings(\"unchecked\")\n            Comparable<? super K> k = (Comparable<? super K>) key;\n            do {\n                parent = t;\n                cmp = k.compareTo(t.key);\n                if (cmp < 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            } while (t != null);\n        }\n        Entry<K, V> e = new Entry<>(key, value, parent);\n        if (cmp < 0)\n            parent.left = e;\n        else\n            parent.right = e;\n        fixAfterInsertion(e);\n        return null;\n    }\n\n    private void fixAfterInsertion(Entry<K, V> x) {\n        x.color = RED;\n\n        while (x != null && x != root && x.parent.color == RED) {\n            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n                Entry<K, V> y = rightOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == rightOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateLeft(x);\n                    }\n                    setColor(parentOf(x), BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateRight(parentOf(parentOf(x)));\n                }\n            } else {\n                Entry<K, V> y = leftOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == leftOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateRight(x);\n                    }\n                    setColor(parentOf(x), BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateLeft(parentOf(parentOf(x)));\n                }\n            }\n        }\n        root.color = BLACK;\n    }\n\n    private static <K, V> boolean colorOf(Entry<K, V> p) {\n        return (p == null ? BLACK : p.color);\n    }\n\n    private static <K, V> Entry<K, V> parentOf(Entry<K, V> p) {\n        return (p == null ? null : p.parent);\n    }\n\n    private static <K, V> void setColor(Entry<K, V> p, boolean c) {\n        if (p != null)\n            p.color = c;\n    }\n\n    private static <K, V> Entry<K, V> leftOf(Entry<K, V> p) {\n        return (p == null) ? null : p.left;\n    }\n\n    private static <K, V> Entry<K, V> rightOf(Entry<K, V> p) {\n        return (p == null) ? null : p.right;\n    }\n\n    private void rotateLeft(Entry<K, V> p) {\n        if (p != null) {\n            Entry<K, V> r = p.right;\n            p.right = r.left;\n            if (r.left != null)\n                r.left.parent = p;\n            r.parent = p.parent;\n            if (p.parent == null)\n                root = r;\n            else if (p.parent.left == p)\n                p.parent.left = r;\n            else\n                p.parent.right = r;\n            r.left = p;\n            p.parent = r;\n        }\n    }\n\n    private void rotateRight(Entry<K, V> p) {\n        if (p != null) {\n            Entry<K, V> l = p.left;\n            p.left = l.right;\n            if (l.right != null) l.right.parent = p;\n            l.parent = p.parent;\n            if (p.parent == null)\n                root = l;\n            else if (p.parent.right == p)\n                p.parent.right = l;\n            else p.parent.left = l;\n            l.right = p;\n            p.parent = l;\n        }\n    }\n\n    public V remove(Object key) {\n        Entry<K, V> p = getEntry(key);\n        if (p == null)\n            return null;\n\n        V oldValue = p.value;\n        deleteEntry(p);\n        return oldValue;\n    }\n\n    final Entry<K, V> getEntry(Object key) {\n        // Offload comparator-based version for sake of performance\n        if (comparator != null)\n            return getEntryUsingComparator(key);\n        if (key == null)\n            throw new NullPointerException();\n        @SuppressWarnings(\"unchecked\")\n        Comparable<? super K> k = (Comparable<? super K>) key;\n        Entry<K, V> p = root;\n        while (p != null) {\n            int cmp = k.compareTo(p.key);\n            if (cmp < 0)\n                p = p.left;\n            else if (cmp > 0)\n                p = p.right;\n            else\n                return p;\n        }\n        return null;\n    }\n\n    final Entry<K, V> getEntryUsingComparator(Object key) {\n        @SuppressWarnings(\"unchecked\")\n        K k = (K) key;\n        Comparator<? super K> cpr = comparator;\n        if (cpr != null) {\n            Entry<K, V> p = root;\n            while (p != null) {\n                int cmp = cpr.compare(k, p.key);\n                if (cmp < 0)\n                    p = p.left;\n                else if (cmp > 0)\n                    p = p.right;\n                else\n                    return p;\n            }\n        }\n        return null;\n    }\n\n    private void deleteEntry(Entry<K, V> p) {\n        // 找到直接后继节点\n        if (p.left != null && p.right != null) {\n            Entry<K, V> s = successor(p);\n            p.key = s.key;\n            p.value = s.value;\n            p = s;\n        }\n\n        // Start fixup at replacement node, if it exists.\n        Entry<K, V> replacement = (p.left != null ? p.left : p.right);\n\n        // 只有一个叶子节点的情况\n        if (replacement != null) {\n            // Link replacement to parent\n            replacement.parent = p.parent;\n            if (p.parent == null)\n                root = replacement;\n            else if (p == p.parent.left)\n                p.parent.left = replacement;\n            else\n                p.parent.right = replacement;\n\n            // Null out links so they are OK to use by fixAfterDeletion.\n            p.left = p.right = p.parent = null;\n\n            // 待删除节点为黑色，且只有一个红色孩子节点\n            if (p.color == BLACK)\n                fixAfterDeletion(replacement);\n        } else if (p.parent == null) { // 只有根节点，直接删除\n            root = null;\n        } else { // 删除叶子节点\n            if (p.color == BLACK)\n                fixAfterDeletion(p);\n\n            if (p.parent != null) {\n                if (p == p.parent.left)\n                    p.parent.left = null;\n                else if (p == p.parent.right)\n                    p.parent.right = null;\n                p.parent = null;\n            }\n        }\n    }\n\n    static <K, V> Entry<K, V> successor(Entry<K, V> t) {\n        if (t == null)\n            return null;\n        else if (t.right != null) {\n            Entry<K, V> p = t.right;\n            while (p.left != null)\n                p = p.left;\n            return p;\n        } else {\n            Entry<K, V> p = t.parent;\n            Entry<K, V> ch = t;\n            while (p != null && ch == p.right) {\n                ch = p;\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n\n    private void fixAfterDeletion(Entry<K, V> x) {\n        while (x != root && colorOf(x) == BLACK) {\n            if (x == leftOf(parentOf(x))) {\n                Entry<K, V> sib = rightOf(parentOf(x));\n\n                // 情况 1-1\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateLeft(parentOf(x));\n                    sib = rightOf(parentOf(x));\n                }\n\n                // 情况 2-1\n                if (colorOf(leftOf(sib)) == BLACK &&\n                    colorOf(rightOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    // 情况 3-1\n                    if (colorOf(rightOf(sib)) == BLACK) {\n                        setColor(leftOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateRight(sib);\n                        sib = rightOf(parentOf(x));\n                    }\n                    // 情况 4-1\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(rightOf(sib), BLACK);\n                    rotateLeft(parentOf(x));\n                    x = root;\n                }\n            } else { // 和上面对称\n                Entry<K, V> sib = leftOf(parentOf(x));\n\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateRight(parentOf(x));\n                    sib = leftOf(parentOf(x));\n                }\n\n                if (colorOf(rightOf(sib)) == BLACK &&\n                    colorOf(leftOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    if (colorOf(leftOf(sib)) == BLACK) {\n                        setColor(rightOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateLeft(sib);\n                        sib = leftOf(parentOf(x));\n                    }\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(leftOf(sib), BLACK);\n                    rotateRight(parentOf(x));\n                    x = root;\n                }\n            }\n        }\n\n        setColor(x, BLACK);\n    }\n\n    final Entry<K,V> getFirstEntry() {\n        Entry<K,V> p = root;\n        if (p != null)\n            while (p.left != null)\n                p = p.left;\n        return p;\n    }\n\n    public boolean containsValue(Object value) {\n        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e)) {\n            if (valEquals(value, e.value))\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n参考：https://www.bilibili.com/video/av23890827/?p=10\nhttps://www.cnblogs.com/qingergege/p/7351659.html\n');
INSERT INTO `article` VALUES (16, 2, 11, '红黑树', '数据结构', '2019-06-21', 0, 0, '## 一、概述\n红黑树 (Red-Black Tree) 是一种特殊的二叉查找树，这意味着它满足二叉查找树的特征：任意一个节点的键值大于其左孩子的键值，且小于等于其右孩子的键值。除了具备二叉查找树的所有特性外，红黑树还包含了许多额外的信息。红黑树的每一个节点上都有一个存储位来表示节点的颜色信息，要么是红色，要么是黑色。一颗红黑树必定满足以下五个特征：\n1. 每个节点要么是红色，要么是黑色\n2. 根节点是黑色\n3. 每个叶子节点的两个空节点是黑色的（后面称之为 NULL 节点）\n4. 每个红色节点的两个子节点都是黑色的（根到每个叶子节点的所有路径上不能有两个连续的红色节点）\n5. 对于任意一个节点而言，它到叶节点的每一条路径上都包含相同数目的黑色节点\n\n<!-- more -->\n\n<center><img src=\"https://debugxw.github.io/img/rbt/rbt_ex.png\" width=\"30%\" height=\"30%\" /></center>\n\n上图所示的红黑树的黑高 BH = 3。虽然红黑树不像 AVL 树一样，在高度上永远保持绝对的平衡，但是红黑树会保持相对平衡即 BH(left) == BH(right)，也就是说任意一个节点到叶子节点的最长路径不会超过最短路径长度的二倍（不包括最后的 NULL 节点）。\n**定理：**有 N 个节点的红黑树，树的最大高度是 2log(N+1)。\n\n## 二、插入\n当向一颗红黑树中插入一个节点后，就有可能破坏红黑树的平衡，这时就需要做相应的调整，使得红黑树依旧满足上面所说的五个特性。插入一个节点时，首先按照平衡二叉树的插入规则将新节点添加到相应的位置，然后再进行调整。\n\n首先我们想一下，新插入的节点应该是红色的还是黑色的呢？答案是红色。因为如果新插入的节点是黑色，则一定会违背上面的第五个特性，而如果新节点是红色的，则有可能违背第四个特性，也有可能不违背上面五个特性之中的任意一个，即插入新节点之后树还是平衡的。这就意味着我们调整时，如果新节点是红色的，我们处理的情况就会少一些。接下来，就是如何调整这棵树，努力使得它满足以上的五个特性，那么它就又重新变成了一颗正统的红黑树了！！！\n\n为了方便讲述，进行如下规定（下图插入 X 后需要调整）：\n+ 新插入的节点（当前节点）为 X，父节点为 P，祖父节点为 G，叔叔节点为 Y\n+ A3 表示该子树的黑高 BH = 3，B3 表示该子树的黑高 BH = 3，C2 表示...\n\n<center><img src=\"../../../../img/rbt/rbt_ex.png\" width=\"30%\" height=\"30%\" /></center>\n\n#### 1、无需调整\n插入节点后，有两种情况无需调整：\n+ X 为根节点，这时只需将根节点由红染黑即可。注意：如果在后续的回溯过程中 X 变为根节点，也属于这种情况\n+ 父节点 P 为黑色，则当前树满足上面的所有特性，无需调整\n\n#### 2、需要调整\n插入新节点后，有六种情况需要调整，而前三种和后三种是两两对称的：\n+ P 为 G 的左子树：\n  + a：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G\n  <center><img src=\"../../../../img/rbt/rbt_a.png\" width=\"60%\" height=\"60%\" /></center>\n  + b：Y 为黑，X 为右子树；左旋 P，当前节点 X 变为 P（即把 P 当做新插入的节点），转化为 c（如果G 的右子树为空，即 Y 为空，那么 Y 就是空的黑色叶子节点）\n  <center><img src=\"../../../../img/rbt/rbt_b.png\" width=\"60%\" height=\"60%\" /></center>\n  + c：Y 为黑，X 为左子树；P 染黑，G 染红，右旋 G，结束\n  <center><img src=\"../../../../img/rbt/rbt_c.png\" width=\"60%\" height=\"60%\" /></center>\n+ P 为 G 的右子树：\n  + d：Y 为红，X 可左可右；P、Y 变黑，G 变红，X 回溯至 G\n  + e：Y 为黑，X 为左子树；右旋 P，当前节点 X 变为 P，转化为 f\n  + f：Y 为黑，X 为右子树；P 染黑，G 染红，左旋 G，结束\n\n可以看到，其实上面的 a 和 d 两种情况的调整操作是一样的，而这六种情况的核心思路都是：**将红色节点移动到根节点，然后将根节点染黑。**\n#### 3、构建红黑树\n假设要插入的节点依次为 [12, 1, 9, 0, 3, 5, 4]，则构建红黑树的过程如下（这里省略了 NULL 节点）：\n\n<center><img src=\"../../../../img/rbt/rbt_insert.png\" width=\"90%\" height=\"90%\" /></center>\n\n#### AVL 插入 VS RBT 插入\n+ 插入元素都是 BST 的插入，区别在于调整\n+ 旋转次数：AVL 和 RBT 都是 O(1)\n+ 指针回溯次数，最好：\n  + 很早就遇到单旋或双旋的情况，为 O(1)\n  + 很早就遇到 b、c 或者 e、f 的情况，为 O(1)\n+ 指针回溯次数，最坏：\n  + 回溯到根节点才发现平衡因子大于 1 或小于 -1，为 O(logN)\n  + 不断执行 a 情况，直到根节点，**但每次向上回溯两层，**为 O(logN / 2)\n+ 插入效率：RBT 略好于 AVL\n+ 查询效率：AVL 略好于 RBT\n\n## 三、删除\n对于一棵普通的二叉排序树来说，删除的节点情况可以分为三种：\n1. 待删除节点为叶子节点\n2. 待删除节点只有左子树或只有右子树\n3. 待删除节点既有左子树又有右子树\n\n对于情况 3，要删除既有左子树又有右子树的节点，我们首先要找到该节点的先驱节点或后继节点，然后用先驱节点或后继节点替换该节点，最后按 1 或 2 中的方法删除后继节点即可。这样情况 3 就可以转换为情况 1 或 2。所以我们要删除的节点类型从大的方面来说，就只有两种。\n同样，对于红黑树来说，我们要删除的节点类型大体来讲也只有两种。\n\n#### 1、待删节点只有左子树或只有右子树\n假设待删除节点为 D，D 的父节点为 P，P 的另一个孩子节点为 S，S 的左右子树分别为 SL 和 SR。\n在这种情况下，待删节点 D 不可能为红色（如果 D 为红色，那么一定会违背红黑树的特性 4 或 5，所以 D 只能为黑色）。D 为黑色那么只会出现以下两种情况：\n\n<center><img src=\"../../../../img/rbt/rbt_delete_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n这两种情况的处理方式是一样的，即将 D 的左孩子或右孩子的颜色改成黑色，并用 D 的左孩子或右孩子替换 D，再将 D 删除即可（因为删除 D 以后，以 D 为根的子树上少了一个黑节点，所以要将 D 的孩子由红色变成黑色以保持红黑树的性质）。\n\n#### 2、待删除节点为叶子节点\n**叶子节点为红色**\n如果待删除节点为叶子节点且为红色，那么直接将该节点删除即可（因为删除一个红色叶子节点并不会违反红黑树的任何一个特性）。\n\n**叶子节点为黑色**\n这也是最复杂的一种情况，在调整的过程中，待删除节点 D 可能会向上回溯，回溯之后再看 D 是下面哪种情况进行调整，**直到 D 为红色或者 D 为根节点，这时，将刚开始的待删除节点删除，将此时 D 指向的节点染黑，调整结束**（即先进行调整，调整完成后，再来删除 D）。\n\n**情况1-1**\nD 是 P 的左孩子，且 S 为红色：**P 变成红色，S 变成黑色，左旋 P**（如下图，这里省略了 NULL 节点）。此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_1_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况1-2**\nD 是 P 的右孩子，且 S 为红色：**P 变成红色，S 变成黑色，右旋 P。**此时 D 的兄弟节点变成了黑色，就转变成了后面要讨论的几种情况。（这种情况和情况1-1对称）\n\n**情况2-1**\nD 是 P 的左孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（如下图，在这个例子中，SL、SR 只能为 NULL 节点，D 回溯至 P 之后发现 P 为根节点，这时直接将 P 染黑，删除 D 即可。其中黄色代表红黑均可。）\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_2_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况2-2**\nD 是 P 的右孩子，且 S 为黑色，SL、SR 都为黑色，P 红黑均可：**将 S 染红，D 回溯至 P**（这种情况和情况2-1对称）\n\n**情况3-1**\nD 是 P 的左孩子，且 S 为黑色，SL 为红色，SR 为黑色，P 红黑均可：**SL 染黑，S 染红，右旋 S**（这时就转换为了情况 4-1）。\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_3_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况3-2**\nD 是 P 的右孩子，且 S 为黑色，SL 为黑色，SR 为红色，P 红黑均可：**LR 染黑，S 染红，左旋 S**（这时就转换为了情况 4-2，和情况3-1对称）。\n\n**情况4-1**\nD 是 P 的左孩子，且 S 为黑色，SR 为红色，SL 红黑均可（如果 SL 为黑色，那么一定为 NULL 节点）：**将 S 染为 P 的颜色，P 和 SR 染黑，左旋 P**，此时 D 回溯至根节点。（在下面这个例子中，指针回溯之后，发现指针指向根节点，这时直接将根节点 S 染为黑色，删除 D 即可）\n\n<center><img src=\"../../../../img/rbt/rbt_delete_2_4_1.png\" width=\"60%\" height=\"60%\" /></center>\n\n**情况4-2**\nD 是 P 的右孩子，且 S 为黑色，SL 为红色，SR 红黑均可：**将 S 染为 P 的颜色，P 和 SL 染黑，左旋 P**，此时 D 回溯至根节点（和情况 4-1 对称）。\n\n#### 3、删除红黑树样例\n\n<center><img src=\"../../../../img/rbt/rbt_delete_3.png\" width=\"90%\" height=\"90%\" /></center>\n\n## 四、AVL 树和 RBT 树的应用\n+ 红黑树\n  + 广泛用于 c++ 的 STL 中，map 和 set 都是用红黑树实现的\n  + 著名的 Linux 进程调度 Completely Fair Scheduler，用红黑树管理进程控制块，进程的虚拟内存区域都存储在一棵红黑树上，每个虚拟地址区域都对应一个红黑树节点，左指针指向相邻的低地址虚拟存储区域，右指针指向相邻的高地址虚拟地址空间\n  + IO 多路复用 epoll 的实现采用红黑树组织管理 sockfd，以支持快速的增删改查\n  + ngnix 中用红黑树管理 timer，因为红黑树是有序的，可以很快的得到距离当前最小的定时器\n  + JDK1.8 中 TreeMap、HashMap、ConcurrentHashMap 的实现采用了红黑树\n+ 虽然 AVL 树的查找效率很高，但由于维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多\n  + Windows 对进程地址空间的管理用到了 AVL 树\n  + Windows NT 内核中广泛存在\n\n## 五、TreeMap 和 TreeSet\n### TreeMap\nTreeMap 是 java 中用来存储可排序键值对的一种容器，其内部使用的数据结构就是红黑树。每个红黑树节点存储一个 key-value 键值对，并根据 key 进行排序，排序的方式有两种：\n+ 自然排序：此时，所有的 key 必须实现 Comparable 接口，用于比较两个 key 的大小\n+ 定制排序：定义 TreeMap 时，新建一个 Comparator 对象，该对象用于比较任意两个 key 的大小\n\n注意：如果使用自定义的类作为 TreeMap 中的 key 和 value，且想让 TreeMap 能够良好的工作，**则必须重写自定义类中的 equals 方法。**例如在 containsValue 中比较两个 value 是否相同就用到了 valEquals() 方法，而 valEquals() 方法则用到了对象的 equals 方法，源码如下：\n```java\n    public boolean containsValue(Object value) {\n        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e))\n            if (valEquals(value, e.value))\n                return true;\n        return false;\n    }\n    \n    static final boolean valEquals(Object o1, Object o2) {\n        return (o1==null ? o2==null : o1.equals(o2));\n    }\n```\n\n### TreeSet\nTreeSet 是 java 中用来存储不能重复且有序的数据的一种容器。但在本质上，TreeSet 其实是用 TreeMap 来存储数据的。在 TreeSet 的源码中，有如下两个成员：\n```java\n    /**\n     * The backing map.\n     */\n    private transient NavigableMap<E,Object> m;\n\n    // Dummy value to associate with an Object in the backing Map\n    private static final Object PRESENT = new Object();\n```\n这里的 NavigableMap 只是一个接口，但在构造 TreeSet 的时候会将 m 初始化为一个 TreeMap，这个 TreeMap 就是用来存储数据的容器。TreeSet 将所有的数据存储在 m 的 key 中，因为 TreeMap 中的 key 是唯一的且有序，所以也就达到了 TreeSet 存储不重复元素且有序的目的。在向 TreeSet 中添加一个元素时，实际上是调用了 TreeMap 的 put() 方法：\n```java\n    public boolean add(E e) {\n        return m.put(e, PRESENT)==null;\n    }\n```\n可以看到，在添加元素时，TreeSet 将元素作为 key 添加到 m 中，而 value 则放入一个 Object 常量（本质上 value 没什么卵用），也就是说 m 中存储的所有键值对的 key 都不相同，而 value 都相同。\nTreeSet 中的其它方法，其实也都是直接调用了 TreeMap 中的方法，例如：\n```java\n    public boolean remove(Object o) {\n        return m.remove(o)==PRESENT;\n    }\n    \n    public boolean contains(Object o) {\n        return m.containsKey(o);\n    }\n    \n    public int size() {\n        return m.size();\n    }\n```\n\n## 六、源代码（java 实现）\n由于本人太菜，写不出红黑树的代码，所以就把 TreeMap 中的部分源码给扣了下来。\n```java\nimport java.util.Comparator;\n\npublic class RBTree<K, V> {\n\n    private static final boolean RED = false;\n    private static final boolean BLACK = true;\n\n    private Entry<K, V> root;\n\n    private final Comparator<? super K> comparator;\n\n    public RBTree() {\n        comparator = null;\n    }\n\n    public RBTree(Comparator<? super K> comparator) {\n        this.comparator = comparator;\n    }\n\n    static final class Entry<K, V> {\n        K key;\n        V value;\n        Entry<K, V> left;\n        Entry<K, V> right;\n        Entry<K, V> parent;\n        boolean color = BLACK;\n\n        Entry(K key, V value, Entry<K, V> parent) {\n            this.key = key;\n            this.value = value;\n            this.parent = parent;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n\n        public V setValue(V value) {\n            V oldValue = this.value;\n            this.value = value;\n            return oldValue;\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof Entry))\n                return false;\n            Entry<?, ?> e = (Entry<?, ?>) o;\n\n            return valEquals(key, e.getKey()) && valEquals(value, e.getValue());\n        }\n\n        public int hashCode() {\n            int keyHash = (key == null ? 0 : key.hashCode());\n            int valueHash = (value == null ? 0 : value.hashCode());\n            return keyHash ^ valueHash;\n        }\n\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n\n    static final boolean valEquals(Object o1, Object o2) {\n        return (o1 == null ? o2 == null : o1.equals(o2));\n    }\n\n    public V put(K key, V value) {\n        Entry<K, V> t = root;\n        if (t == null) {\n            root = new Entry<>(key, value, null);\n            return null;\n        }\n        int cmp;\n        Entry<K, V> parent;\n        // split comparator and comparable paths\n        Comparator<? super K> cpr = comparator;\n        if (cpr != null) {\n            do {\n                parent = t;\n                cmp = cpr.compare(key, t.key);\n                if (cmp < 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            } while (t != null);\n        } else {\n            if (key == null)\n                throw new NullPointerException();\n            @SuppressWarnings(\"unchecked\")\n            Comparable<? super K> k = (Comparable<? super K>) key;\n            do {\n                parent = t;\n                cmp = k.compareTo(t.key);\n                if (cmp < 0)\n                    t = t.left;\n                else if (cmp > 0)\n                    t = t.right;\n                else\n                    return t.setValue(value);\n            } while (t != null);\n        }\n        Entry<K, V> e = new Entry<>(key, value, parent);\n        if (cmp < 0)\n            parent.left = e;\n        else\n            parent.right = e;\n        fixAfterInsertion(e);\n        return null;\n    }\n\n    private void fixAfterInsertion(Entry<K, V> x) {\n        x.color = RED;\n\n        while (x != null && x != root && x.parent.color == RED) {\n            if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {\n                Entry<K, V> y = rightOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == rightOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateLeft(x);\n                    }\n                    setColor(parentOf(x), BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateRight(parentOf(parentOf(x)));\n                }\n            } else {\n                Entry<K, V> y = leftOf(parentOf(parentOf(x)));\n                if (colorOf(y) == RED) {\n                    setColor(parentOf(x), BLACK);\n                    setColor(y, BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    x = parentOf(parentOf(x));\n                } else {\n                    if (x == leftOf(parentOf(x))) {\n                        x = parentOf(x);\n                        rotateRight(x);\n                    }\n                    setColor(parentOf(x), BLACK);\n                    setColor(parentOf(parentOf(x)), RED);\n                    rotateLeft(parentOf(parentOf(x)));\n                }\n            }\n        }\n        root.color = BLACK;\n    }\n\n    private static <K, V> boolean colorOf(Entry<K, V> p) {\n        return (p == null ? BLACK : p.color);\n    }\n\n    private static <K, V> Entry<K, V> parentOf(Entry<K, V> p) {\n        return (p == null ? null : p.parent);\n    }\n\n    private static <K, V> void setColor(Entry<K, V> p, boolean c) {\n        if (p != null)\n            p.color = c;\n    }\n\n    private static <K, V> Entry<K, V> leftOf(Entry<K, V> p) {\n        return (p == null) ? null : p.left;\n    }\n\n    private static <K, V> Entry<K, V> rightOf(Entry<K, V> p) {\n        return (p == null) ? null : p.right;\n    }\n\n    private void rotateLeft(Entry<K, V> p) {\n        if (p != null) {\n            Entry<K, V> r = p.right;\n            p.right = r.left;\n            if (r.left != null)\n                r.left.parent = p;\n            r.parent = p.parent;\n            if (p.parent == null)\n                root = r;\n            else if (p.parent.left == p)\n                p.parent.left = r;\n            else\n                p.parent.right = r;\n            r.left = p;\n            p.parent = r;\n        }\n    }\n\n    private void rotateRight(Entry<K, V> p) {\n        if (p != null) {\n            Entry<K, V> l = p.left;\n            p.left = l.right;\n            if (l.right != null) l.right.parent = p;\n            l.parent = p.parent;\n            if (p.parent == null)\n                root = l;\n            else if (p.parent.right == p)\n                p.parent.right = l;\n            else p.parent.left = l;\n            l.right = p;\n            p.parent = l;\n        }\n    }\n\n    public V remove(Object key) {\n        Entry<K, V> p = getEntry(key);\n        if (p == null)\n            return null;\n\n        V oldValue = p.value;\n        deleteEntry(p);\n        return oldValue;\n    }\n\n    final Entry<K, V> getEntry(Object key) {\n        // Offload comparator-based version for sake of performance\n        if (comparator != null)\n            return getEntryUsingComparator(key);\n        if (key == null)\n            throw new NullPointerException();\n        @SuppressWarnings(\"unchecked\")\n        Comparable<? super K> k = (Comparable<? super K>) key;\n        Entry<K, V> p = root;\n        while (p != null) {\n            int cmp = k.compareTo(p.key);\n            if (cmp < 0)\n                p = p.left;\n            else if (cmp > 0)\n                p = p.right;\n            else\n                return p;\n        }\n        return null;\n    }\n\n    final Entry<K, V> getEntryUsingComparator(Object key) {\n        @SuppressWarnings(\"unchecked\")\n        K k = (K) key;\n        Comparator<? super K> cpr = comparator;\n        if (cpr != null) {\n            Entry<K, V> p = root;\n            while (p != null) {\n                int cmp = cpr.compare(k, p.key);\n                if (cmp < 0)\n                    p = p.left;\n                else if (cmp > 0)\n                    p = p.right;\n                else\n                    return p;\n            }\n        }\n        return null;\n    }\n\n    private void deleteEntry(Entry<K, V> p) {\n        // 找到直接后继节点\n        if (p.left != null && p.right != null) {\n            Entry<K, V> s = successor(p);\n            p.key = s.key;\n            p.value = s.value;\n            p = s;\n        }\n\n        // Start fixup at replacement node, if it exists.\n        Entry<K, V> replacement = (p.left != null ? p.left : p.right);\n\n        // 只有一个叶子节点的情况\n        if (replacement != null) {\n            // Link replacement to parent\n            replacement.parent = p.parent;\n            if (p.parent == null)\n                root = replacement;\n            else if (p == p.parent.left)\n                p.parent.left = replacement;\n            else\n                p.parent.right = replacement;\n\n            // Null out links so they are OK to use by fixAfterDeletion.\n            p.left = p.right = p.parent = null;\n\n            // 待删除节点为黑色，且只有一个红色孩子节点\n            if (p.color == BLACK)\n                fixAfterDeletion(replacement);\n        } else if (p.parent == null) { // 只有根节点，直接删除\n            root = null;\n        } else { // 删除叶子节点\n            if (p.color == BLACK)\n                fixAfterDeletion(p);\n\n            if (p.parent != null) {\n                if (p == p.parent.left)\n                    p.parent.left = null;\n                else if (p == p.parent.right)\n                    p.parent.right = null;\n                p.parent = null;\n            }\n        }\n    }\n\n    static <K, V> Entry<K, V> successor(Entry<K, V> t) {\n        if (t == null)\n            return null;\n        else if (t.right != null) {\n            Entry<K, V> p = t.right;\n            while (p.left != null)\n                p = p.left;\n            return p;\n        } else {\n            Entry<K, V> p = t.parent;\n            Entry<K, V> ch = t;\n            while (p != null && ch == p.right) {\n                ch = p;\n                p = p.parent;\n            }\n            return p;\n        }\n    }\n\n    private void fixAfterDeletion(Entry<K, V> x) {\n        while (x != root && colorOf(x) == BLACK) {\n            if (x == leftOf(parentOf(x))) {\n                Entry<K, V> sib = rightOf(parentOf(x));\n\n                // 情况 1-1\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateLeft(parentOf(x));\n                    sib = rightOf(parentOf(x));\n                }\n\n                // 情况 2-1\n                if (colorOf(leftOf(sib)) == BLACK &&\n                    colorOf(rightOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    // 情况 3-1\n                    if (colorOf(rightOf(sib)) == BLACK) {\n                        setColor(leftOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateRight(sib);\n                        sib = rightOf(parentOf(x));\n                    }\n                    // 情况 4-1\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(rightOf(sib), BLACK);\n                    rotateLeft(parentOf(x));\n                    x = root;\n                }\n            } else { // 和上面对称\n                Entry<K, V> sib = leftOf(parentOf(x));\n\n                if (colorOf(sib) == RED) {\n                    setColor(sib, BLACK);\n                    setColor(parentOf(x), RED);\n                    rotateRight(parentOf(x));\n                    sib = leftOf(parentOf(x));\n                }\n\n                if (colorOf(rightOf(sib)) == BLACK &&\n                    colorOf(leftOf(sib)) == BLACK) {\n                    setColor(sib, RED);\n                    x = parentOf(x);\n                } else {\n                    if (colorOf(leftOf(sib)) == BLACK) {\n                        setColor(rightOf(sib), BLACK);\n                        setColor(sib, RED);\n                        rotateLeft(sib);\n                        sib = leftOf(parentOf(x));\n                    }\n                    setColor(sib, colorOf(parentOf(x)));\n                    setColor(parentOf(x), BLACK);\n                    setColor(leftOf(sib), BLACK);\n                    rotateRight(parentOf(x));\n                    x = root;\n                }\n            }\n        }\n\n        setColor(x, BLACK);\n    }\n\n    final Entry<K,V> getFirstEntry() {\n        Entry<K,V> p = root;\n        if (p != null)\n            while (p.left != null)\n                p = p.left;\n        return p;\n    }\n\n    public boolean containsValue(Object value) {\n        for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e)) {\n            if (valEquals(value, e.value))\n                return true;\n        }\n        return false;\n    }\n}\n```\n\n参考：https://www.bilibili.com/video/av23890827/?p=10\nhttps://www.cnblogs.com/qingergege/p/7351659.html\n');
INSERT INTO `article` VALUES (17, 2, 11, 'AQS', 'java', '2019-06-21', 0, 0, 'AbstractQueuedSynchronizer 简称 AQS，其依赖于先进先出等待队列实现了阻塞锁和相关的同步器。对于大多数依赖于某个整形值 status 来表示状态的同步器，都可以通过继承 AQS 来实现。AQS 定义了两种资源共享方式：独占和共享。子类只须重写其中的某些方法，并明确定义 status 在对象获得锁或释放锁时意味着什么，而其余的工作，例如维护等待列队，阻塞与唤醒等 AQS 都已经帮我们实现好了。\n\n<!-- more -->\n\nAQS 以模板方法模式在内部定义了获取和释放同步状态的模板方法，并留下钩子函数供子类继承时进行扩展，由子类决定在获取和释放同步状态时的细节，从而实现满足自身功能特性的需求。除此之外，AQS 通过内部的同步队列管理获取同步状态失败的线程，向实现者屏蔽了线程阻塞和唤醒的细节。\n自定义同步器时，需要重新定义以下方法：\n+ boolean tryAcquire(int): 独占锁模式下，尝试获取锁，成功返回 true，失败则返回 false\n+ boolean tryRelease(int): 独占锁模式下，尝试释放锁，成功返回 true，失败则返回 false\n+ int tryAcquireShared(int): 共享锁模式下，尝试获取锁。返回一个整形，负数代表获取失败；零代表获取成功，但已经没有剩余资源；正数代表获取成功，且还有可用资源\n+ boolean tryReleaseShared(int): 共享锁模式下，尝试释放锁。如果释放后允许后续节点获取锁成功，返回 true，否则返回 false\n+ isHeldExclusively(): 判断该线程是否正在独占资源。只有用到了 Condition 才去实现它\n\n下面以 ReentrantLock 为例，从源码中分析如何通过 AQS 实现一个同步器。\n\n### 一、ReentrantLock 概述\nJDK 中独占锁的实现除了用 synchronized 外，还可以使用 ReentrantLock。虽然在性能上两者没有太大的区别，但是 ReentrantLock 相对于 synchronized 而言提供了较为丰富的功能，使用起来更加灵活，也更加适合复杂的并发场景。两者的比较：\n+ 都是可重入锁\n+ synchronized 表现为原生语法 (JVM) 层面的互斥锁，ReentrantLock 则表现为 API 层面的互斥锁（需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成）\n+ 相比 synchronized，ReentrantLock 增加了一些高级功能，主要有以下三项：**等待可中断，可实现公平锁，锁可以绑定多个条件（可实现选择性通知）**\n\n### 二、AQS 的内部结构\nAQS 内部主要有如下几个成员变量：\n```java\n    /**\n     * The synchronization state.\n     */\n    private volatile int state;\n    \n    /**\n     * Head of the wait queue, lazily initialized.  Except for\n     * initialization, it is modified only via method setHead.  Note:\n     * If head exists, its waitStatus is guaranteed not to be\n     * CANCELLED.\n     */\n    private transient volatile Node head;       //指向同步等待队列的头\n    \n    /**\n     * Tail of the wait queue, lazily initialized.  Modified only via\n     * method enq to add new wait node.\n     */\n    private transient volatile Node tail;       //指向同步等待队列的尾\n```\n其中的 state 是一个带 volatile 的变量，表示线程同步状态，它在不同的组件中有不同的含义。例如在 ReentrantLock 中，state 代表锁被重入的次数。head 和 tail 表示 AQS 内部用于维护被阻塞线程的队列的头结点和尾节点。其中的 Node 是 AQS 的一个内部类，主要有以下几个成员变量：\n```java\n    volatile int waitStatus;        // 等待状态\n    \n    volatile Node prev;     // 指向前一个节点\n    \n    volatile Node next;     // 指向后一个节点\n    \n    volatile Thread thread;     // 当前节点所代表的线程\n```\nthread 代表当前节点所表示的线程，因为同步队列中的节点内部封装了之前竞争锁失败的线程，故而节点内部必然有一个对应线程实例的引用。waitStatus 代表节点的等待状态，一共有五个取值：\n```java\n        /** waitStatus value to indicate thread has cancelled */\n        static final int CANCELLED =  1;\n        /** waitStatus value to indicate successor\'s thread needs unparking */\n        static final int SIGNAL    = -1;\n        /** waitStatus value to indicate thread is waiting on condition */\n        static final int CONDITION = -2;\n        /**\n         * waitStatus value to indicate the next acquireShared should\n         * unconditionally propagate\n         */\n        static final int PROPAGATE = -3;\n```\nwaitStatus 初始状态为 0。CANCELLED 表示在同步队列中等待的线程因为超时或者被中断，取消继续等待。SIGNAL 表示当前节点在释放锁后需要唤醒后续节点。CONDITION 表示当前节点正在某个 condition 上等待。PROPAGATE 表示下一次的共享模式同步状态的获取将会无条件的传播。\n\nAQS 中还有一个表示持有同步状态的线程标志：\n```java\n    /**\n     * The current owner of exclusive mode synchronization.\n     */\n    private transient Thread exclusiveOwnerThread;\n```\n这个变量继承自 AQS 的父类 AbstractOwnableSynchronizer，用来标识在独占同步模式下，锁被哪一个线程持有。\n\n### 三、ReentrantLock 的内部类\nReentrantLock 有三个静态内部类 Sync、FairSync 和 NonfairSync。Sync 继承自 AQS，FairSync 和 NonFairSync 又继承自 Sync。因为 ReentrantLock 是独占锁，所以 FairSync 和 NonFairSync 重写了 AQS 中的 tryAcquire() 方法，而释放锁的方法 tryRelease() 在 Sync 中被重写。ReentrantLock 正是通过 FairSync 和 NonfairSync 来实现公平锁和非公平锁的。\n\n### 四、ReentrantLock 非公平模式下的加锁流程\n##### 1、构造器\n```java\n    public ReentrantLock() {\n        sync = new NonfairSync();\n    }\n    \n    public ReentrantLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n    }\n```\nReentrantLock 只有这两个构造器，默认情况下使用非公平模式，如果想要使用公平锁，只需在构造时传入参数 true 即可。\n\n##### 2、lock() 方法\n加锁从 ReentrantLock.lock() 开始，而 ReentrantLock.lock() 在内部会直接调用 NonFairSync.lock()：\n```java\n    final void lock() {\n        // 以 CAS 方式将 state 由 0 更新为 1\n        if (compareAndSetState(0, 1))\n            // 如果成功，则将当前线程设置为持有锁的线程，然后直接返回\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);     // 获取锁失败后执行该方法\n    }\n```\n首先尝试快速获取锁，以 CAS 的方式将 state 的值更新为 1，只有当 state 的原值为 0 时更新才能成功，因为 state 在 ReentrantLock 的语境下等同于锁被线程重入的次数，这意味着只有当前锁未被任何线程持有时该方法才会返回成功。若获取锁成功，则将当前线程标记为持有锁的线程，然后整个加锁流程就结束了。若获取锁失败，则执行 acquire() 方法：\n```java\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\nacquire() 方法是 AQS 中定义的方法，它封装了加锁流程中的主要处理逻辑。首先使用 tryAcquire() 尝试获取锁，如果失败则将当前线程封装成节点并添加到等待队列尾部。然后调用 acquireQueued() 让线程在等待队列中获取锁，直到获取锁成功才返回。如果在整个等待过程中被中断过，返回 true，否则返回 false。如果线程在等待过程中被中断，它不会立即响应。在获取到锁后才调用 selfInterrupt()，将中断补上。\n\n##### 3、tryAcquire() 方法\n该方法用于尝试获取独占锁，如果成功返回 true，失败则返回 false。AQS.tryAcquire() 源码如下：\n```java\n    protected boolean tryAcquire(int arg) {\n        throw new UnsupportedOperationException();\n    }\n```\ntryAcquire() 是 AQS 中定义的钩子函数，该方法默认会抛出异常。它会强制同步组件在通过 AQS 来实现同步功能时必须重写该方法。既然是钩子函数，那为什么不把它们声明为 abstract 方法，而是直接抛出异常呢？这是因为实现不同的同步器只需要用到 AQS 中定义的部分钩子函数，如果使用 abstract，那么自定义的同步器就需要重写 AQS 中的全部钩子函数，设计者站在使用者的角度上，将这些方法直接抛出异常，那么子类就可以只重写那些要用得到的方法。\nReentrantLock 在公平和非公平模式下对此有不同的实现，非公平模式下 NonfairSync.tryAcquire() 的实现如下：\n```java\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n```\n底层直接调用到了 ReentrantLock.Sync.nonfairTryAcquire()，从名字上我们就可以知道这是非公平模式下尝试获取锁的实现方式：\n```java\n    /**\n         * Performs non-fair tryLock.  tryAcquire is implemented in\n         * subclasses, but both need nonfair try for trylock method.\n         */\n        final boolean nonfairTryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {       // 如果 state 为 0，说明锁尚未被任何线程占有\n                if (compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);       // 将当前线程标记为持有锁的线程\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {        // 当前线程正持有锁，且锁将要被重入\n                int nextc = c + acquires;\n                if (nextc < 0) // overflow\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);        // 设置 state，代表被重入的次数\n                return true;\n            }\n            return false;\n        }\n```\n这是非公平模式下获取锁的通用方式，它囊括了线程在获取锁时的所有情况：\n+ 如果 state 为 0，说明锁未被任何线程持有，则以 CAS([更多关于 CAS](https://debugxw.github.io/2019/04/26/Compare-and-Swap/)) 的方式将 state 设置为 1，并将当前线程标记为持有锁的线程，获取锁成功，返回 true。如果 state 不为 0，则说明已有线程占有锁，执行第二步操作。或者 CAS 操作失败，说明在判断 state == 0 之后，CAS 操作之前有其他的线程占有了锁，返回 false。\n+ 如果当前线程为正持有锁的线程，则将锁的重入次数加 1，返回 true。这里不再需要加锁，因为该线程之前已经获得了锁，所以这个累加操作不用再进行同步\n+ 如果锁已被其它线程占有，返回 false。\n\n因为 ReentrantLock 用 state 来统计锁被线程重入的次数，所以当前线程尝试获取锁的操作是否成功可以简化理解为：state 的值是否成功累加 1，是则尝试获取锁成功，否则尝试获取锁失败。既然 tryAcquire() 方法囊括了线程在尝试获取锁的所有情况，那么为什么在刚刚进入 NonFairSync.lock() 方法时还要通过 compareAndSetState(0, 1) 去尝试获取锁呢？我们完全可以把 compareAndSetState(0, 1)去掉，对最后的结果不会有任何影响。这种在进行通用逻辑处理之前针对某些特殊情况提前进行处理的方式在后面还会看到，一个直观的想法就是它能提升性能，而代价是牺牲一定的代码简洁性。\n\n##### 4、addWaiter() 方法\n```java\n    /**\n     * Creates and enqueues node for current thread and given mode.\n     *\n     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared\n     * @return the new node\n     */\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        Node pred = tail;\n        if (pred != null) {\n            node.prev = pred;\n            // 如果 tail 不为空且 CAS 操作成功，则提前处理以提升性能\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);      // 包含所有的入队逻辑\n        return node;\n    }\n```\nAQS.addWaiter() 方法会将当前线程封装成一个新的节点，并添加到等待队列末尾。if 语句中的入队逻辑在 enq() 方法中也有，之所以加上这部分重复代码和尝试获取锁时的重复代码一样，对某些特殊情况进行特殊处理，牺牲一定的代码可读性来换取性能的提升。enq() 源码如下：\n```java\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            if (t == null) { // Must initialize\n                // 如果队列为空，则构造新节点，以 CAS 的方式设置新节点为队首元素\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                // 队列不为空，以 CAS 的方式将 node 添加至队列末尾\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n外层的 for 循环相当于一个 CAS 自旋操作，它可以保证所有获取锁失败的线程经过失败重试后最后都能加入同步队列。注意当前线程所在的结点不能直接插入空队列，**因为阻塞的线程是由前驱结点进行唤醒的**。故先要插入一个结点作为队列首元素，当锁释放时由它来唤醒后面被阻塞的线程，在逻辑上这个队列首元素也可以表示当前已经获取锁的线程。\n\n##### 5、acquireQueued() 方法\n```java\n/**\n     * Acquires in exclusive uninterruptible mode for thread already in\n     * queue. Used by condition wait methods as well as acquire.\n     *\n     * @param node the node\n     * @param arg the acquire argument\n     * @return {@code true} if interrupted while waiting\n     */\n    final boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();      // 获得 node 的前驱节点\n                // 如果前驱节点为 head，且尝试获取锁成功\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return interrupted;\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&        // 判断是否要阻塞当前线程\n                    parkAndCheckInterrupt())        // 阻塞当前线程，并检查线程被阻塞期间是否被中断\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n该方法会使线程在队列中等待，直到获取锁后才返回，在整个等待过程中线程并不响应中断，直到获取锁后才执行 selfInterrupt() 方法，将中断补上。在第一个 if 语句中，当前线程首先会判断前驱结点是否是头结点，当前线程的前驱节点为头结点时，有以下两种情况：\n+ head 节点的 thread 为空（由前面的 addWaiter 方法保证了如果队列为空，则会新建一个 thread 为空的 head 节点）\n+ head 节点的 thread 不为空，这时 head.thread 可能持有锁，也有可能已经释放锁\n\n在这两种情况下，当前线程都会尝试去获取锁，如果成功获取锁则会设置当前结点为头结点并返回。\n\n第二个 if 语句中首先会调用 shouldParkAfterFailedAcquire() 方法判断是否应该阻塞线程，内容如下：\n```java\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true;\n        if (ws > 0) {   // waitStatus 为 CANCALLED\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {    // 初始状态（ReentrantLock 语境下）\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don\'t park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n大致逻辑如下：\n+ pre.waitStatus 为 SIGNAL，表示前驱节点释放锁后会唤醒当前节点，当前线程可以安全的被阻塞，返回 true\n+ pre.waitStatus 为 CANCELED，即前驱节点线程任务被取消，为了保证当前线程阻塞后能够被唤醒，则一直往队列头部回溯直到找到一个状态不为 CANCELLED 的结点，然后将当前节点 node 连接在这个结点的后面\n+ pre.waitStatus 为初始状态，则用 CAS 将 pre.waitStatus 设置为 SIGNAL\n\n这个方法的大致思路是要确保当前结点的前驱结点的状态为 SIGNAL，SIGNAL 意味着线程释放锁后会唤醒后面阻塞的线程。**毕竟，只有确保能够被唤醒，当前线程才能放心的阻塞。**但是注意，只有上面的第一种情况才会直接返回 true 并阻塞线程，后两种情况都会返回 false 并重新执行 acquireQueued() 中的 for 循环。这种延迟阻塞其实也是一种高并发场景下的优化，试想如果锁被占用的时间非常短，那么就有可能在重新执行循环的时候成功获取了锁，这样的话线程阻塞与唤醒的开销就省了下来。\n\n最后再来看一下阻塞线程的方法 parkAndCheckInterrupt()：\n```java\n    private final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n很简单直接调用了 LockSupport.park() 阻塞线程（[更多关于 LockSupport](https://debugxw.github.io/2019/05/30/LockSupport/)），当线程被唤醒后，如果在阻塞过程中被中断，则返回 true，否则返回 false。\n\n### 五、ReentrantLock 非公平模式下的解锁流程\n解锁从 ReentrantLock.unlock() 开始，而 ReentrantLock.unlock() 会调用 AQS 中的 release() 方法：\n```java\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {      // 尝试释放锁\n            Node h = head;\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);     // 唤醒等待列队中的一个线程\n            return true;\n        }\n        return false;\n    }\n```\n先来看 tryRelease() 方法：\n```java\n    protected final boolean tryRelease(int releases) {\n            int c = getState() - releases;      // 持有锁次数减一\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) {\n                free = true;\n                setExclusiveOwnerThread(null);      // 清除锁的持有线程标记\n            }\n            setState(c);        // 更新 state 的值\n            return free;\n        }\n```\ntryRelease() 也是 AQS 中定义的一个钩子函数，ReentrantLock 中的 Sync 类对其进行了重写。逻辑很简单，就是将线程持有锁的次数 state 减一，若减少后线程完全释放锁，即 state 为 0，返回 true，否则返回 false。由于执行该方法的线程必然持有锁，故不需要任何同步操作。\n\nrelease() 方法中，如果 tryRelease() 方法返回 true，则表明锁可以被其他线程使用，应该唤醒后续等待线程。但在这之前，还应判断两个条件：\n+ h != null 是为了防止队列为空，即没有任何线程处于等待队列中，那么也就不需要进行唤醒的操作\n+ h.waitStatus != 0 是为了防止队列中虽有线程，但该线程还未阻塞，由前面的分析知，线程在阻塞自己前必须设置前驱结点的状态为 SIGNAL，否则它不会阻塞自己。\n\n接下来就是唤醒操作 unparkSuccessor()：\n```java\n    private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n```\n正常情况下只要唤醒后继结点的线程就行了，但是后继结点可能已经取消等待，所以从队列尾部往前回溯，找到离头结点最近的正常结点，并唤醒其线程。\n\n### 六、公平锁和非公平锁的不同\n在公平模式下，ReentrantLock 对锁的获取有较为严格的限制：在同步队列有线程等待的情况下，所有线程在获取所之前必须先加入同步队列。队列中的线程按加入队列的次序先后获取锁。\n公平锁的加锁入口 FairSync.lock() 如下：\n```java\n    final void lock() {\n        acquire(1);\n    }\n```\n这里直接调用了 AQS.acquire() 方法，与非公平锁 NonFairSync.lock() 相比少了尝试获取锁的步骤，这是第一点不同。接着就是获取锁的通用方法 tryAcquire，该方法在线程未加入队列，加入队列阻塞前和阻塞后被唤醒时都会执行：\n```java\n    protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n```\n可以看到，和非公平锁的 tryAcquire() 方法相比，该方法多了一个 hasQueuedPredecessors() 方法，源码如下：\n```java\n    public final boolean hasQueuedPredecessors() {\n        // The correctness of this depends on head being initialized\n        // before tail and on head.next being accurate if the current\n        // thread is first in queue.\n        Node t = tail; // Read fields in reverse initialization order\n        Node h = head;\n        Node s;\n        return h != t &&\n            ((s = h.next) == null || s.thread != Thread.currentThread());\n    }\n```\n该方法会判断是否有优先级比自己高的线程在队列中等待获取锁。大致逻辑如下：\n+ 如果 h == t，那么可以确定等待队列中一定没有优先级比自己高的线程在等待获取锁，直接返回 false\n+ 如果 h != t 成立，那 (s = h.next) == null 就一定成立啊？为什么还要判断呢？**不要忘记，这时在多线程的环境下。**由之前的分析可以知道，一个节点入队分为三步：\n  + 待添加节点 node 的 pre 指向 tail\n  + CAS 操作更新 tail\n  + 之前的 tail 的 next 指向 node\n所以就有可能出现另一个线程 CAS 更新完 tail，还没来得及将之前的 tail 的 next 指向 node，时间片到了，这个线程开始执行 hasQueuedPredecessors() 方法，此时 (s = h.next) == null 就会为 true。\n+ 如果上面所述的节点加入队列的三个步骤全部完成，即节点已成功加入队列，那么就需要使用 s.thread != Thread.currentThread() 来判断，这个节点是否是当前节点所在的线程。\n\n简单理解：当前有优先级更高的线程在队列中等待，那么当前线程将不会执行 CAS 操作去获取锁，保证了线程获取锁的顺序与加入同步队列的顺序一致，很好的保证了公平性，但也增加了获取锁的成本。\n\n##### 效率问题\nAQS 内部使用 FIFO 实现同步等待队列，既然是先进先出，在公平锁模式下，一个线程尝试获取锁时就会判断同步等待队列中是否已有线程在等待获取锁，如果有则排到队尾，否则尝试获取锁，FIFO 的特性显然很符合公平锁。但同样是 FIFO，它如何实现非公平锁呢？从前面的非公平锁加锁流程中可以看到，线程在加入到同步等待队列之前有两次抢占锁的机会：\n+ 第一次是非重入式的获取锁，只有在当前锁未被任何线程占有（包括自身）时才能成功（NonFairSync.lock() 中）\n+ 第二次是在进入同步队列前，包含所有情况的获取锁的方式（AQS.acquire() 中调用 tryAcquire()）\n\n只有这两次获取锁都失败后，线程才会构造结点并加入同步队列等待。而线程释放锁时是先释放锁（修改 state 值），然后才唤醒后继结点的线程的。试想下这种情况，线程 A 已经释放锁，但还没来得及唤醒后继线程 C，而这时另一个线程 B 刚好尝试获取锁，此时锁恰好不被任何线程持有，它将成功获取锁而不用加入队列等待。线程C被唤醒尝试获取锁，而此时锁已经被线程 B 抢占，故而其获取失败并继续在队列中等待。但在公平锁模式下，线程 B 就不得不加入到等待队列并阻塞，直到 C 唤醒 B。\n\n非公平锁对锁的竞争是抢占式的（队列中线程除外），线程在进入等待队列前可以进行两次尝试，这大大增加了获取锁的机会。这种好处体现在两个方面：\n+ 线程不必加入等待队列就可以获得锁，不仅免去了构造结点并加入队列的繁琐操作，同时也节省了线程阻塞唤醒的开销，线程阻塞和唤醒涉及到线程上下文的切换和操作系统的系统调用。是非常耗时的。在高并发情况下，如果线程持有锁的时间非常短，短到线程入队阻塞的过程超过线程持有并释放锁的时间开销，那么这种抢占式特性对并发性能的提升会更加明显。\n+ 减少CAS竞争。如果线程必须要加入阻塞队列才能获取锁，那入队时 CAS 竞争将变得异常激烈，CAS 操作虽然不会导致失败线程挂起，但不断失败重试导致的对 CPU 的浪费也不能忽视。除此之外，加锁流程中至少有两处通过将某些特殊情况提前来减少 CAS 操作的竞争，增加并发情况下的性能。\n\n### 七、等待可中断\n等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他的事情，可中断特性对处理执行时间非常长的同步块非常有帮助。ReentrantLock 中的 lockInterruptibly() 方法可以实现该功能，lockInterruptibly 相当于是 lock() 的一个衍生品，其解锁方法也为 unlock()。lockInterruptibly 在内部直接调用 AQS 的 acquireInterruptibly() 方法:\n```java\n    public final void acquireInterruptibly(int arg)\n            throws InterruptedException {\n        // 如果在执行 tryAcquire() 之前线程已被中断，则直接抛出 InterruptedException\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (!tryAcquire(arg))\n            doAcquireInterruptibly(arg);\n    }\n```\n在执行 tryAcquire() 方法之前判断线程是否已被中断，这部分重复代码和尝试获取锁时的重复代码一样，对某些特殊情况进行特殊处理，牺牲一定的代码可读性来换取性能的提升。尝试获取锁的方法 tryAcquire() 在 lockInterruptibly() 和 lock() 中都是调用的同一个方法，并没有什么不同。不同的是 doAcquireInterruptibly() 方法：\n```java\n    private void doAcquireInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.EXCLUSIVE);\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n可以看到，该方法和 lock() 中调用的 acquireQueued() 方法在逻辑上大致相同，其中不同的一点是：在 for 循环中的第二个 if 语句中，如果判断条件为 true，那么直接抛出异常，然后由上一级调用者来处理。由前面的分析可知，如果 if 判断条件返回 true，那么就说明在线程阻塞过程中被中断过，则直接抛出异常，然后停止等待，直接返回。而在 acquireQueued() 方法中，如果线程在等待过程中有被中断过，它并不会抛出异常，而是设置一个中断状态标志，最后在成功获得锁之后将这个中断状态标志返回，由上一级调用来决定如何处理。这就是 doAcquireInterruptibly() 实现等待可中断的奥秘。\n\n##### cancelAcquire() 方法\n如果等待被中断，则需要调用用 cancelAcquire() 方法将代表该线程的节点从等待队列中删除：\n```java\n    private void cancelAcquire(Node node) {\n        // Ignore if node doesn\'t exist\n        if (node == null)\n            return;\n\n        node.thread = null;\n\n        // Skip cancelled predecessors\n        Node pred = node.prev;\n        while (pred.waitStatus > 0)\n            node.prev = pred = pred.prev;\n\n        // predNext is the apparent node to unsplice. CASes below will\n        // fail if not, in which case, we lost race vs another cancel\n        // or signal, so no further action is necessary.\n        Node predNext = pred.next;\n\n        // Can use unconditional write instead of CAS here.\n        // After this atomic step, other Nodes can skip past us.\n        // Before, we are free of interference from other threads.\n        node.waitStatus = Node.CANCELLED;\n\n        // If we are the tail, remove ourselves.\n        if (node == tail && compareAndSetTail(node, pred)) {\n            compareAndSetNext(pred, predNext, null);\n        } else {\n            // If successor needs signal, try to set pred\'s next-link\n            // so it will get one. Otherwise wake it up to propagate.\n            int ws;\n            if (pred != head &&\n                ((ws = pred.waitStatus) == Node.SIGNAL ||\n                 (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\n                pred.thread != null) {\n                Node next = node.next;\n                if (next != null && next.waitStatus <= 0)\n                    compareAndSetNext(pred, predNext, next);\n            } else {\n                unparkSuccessor(node);\n            }\n\n            node.next = node; // help GC\n        }\n    }\n```\n\n参考文章：https://www.cnblogs.com/takumicx/p/9402021.html#%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93\n\n');
INSERT INTO `article` VALUES (18, 2, 1, 'Redis和MemCached的区别', 'redis', '2019-07-19', 0, 0, 'Memcached 是一个高性能的分布式内存对象缓存系统，应用于动态 Web 应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态的、数据库驱动的网站速度。\n\nRedis 是一个 key-value 存储系统，和 Memcached 类似，但它支持存储的 value 类型相对更多，包括string、 list、hash、set 和 zset。这些数据类型都支持 push / pop、add / remove 以及取交集、并集和差集等更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis 支持各种不同方式的排序。与 Memcached 一样，为了保证效率，数据都是缓存在内存中。区别在于 Redis 会周期性的把更新的数据写入磁盘或者把修改操作追加到记录文件，并且在此基础上实现了 master-slave 同步。\n\n<!-- more -->\n\n### 一、性能\nRedis 只能使用单核，而 memory cache 可以使用多核，所以在比较上，平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。而在 100k 以上的数据中，Memcached 性能要高于 Redis，虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。说了这么多，结论是，无论你使用哪一个，每秒处理请求的次数都不会成为瓶颈（比如瓶颈可能会是网络延迟）。\n##### Redis 使用单核？\nRedis 是用 “单线程-多路复用 I/O 模型” 来实现高性能的内存数据服务的，这种机制避免了线程间切换和使用锁的开销，但是同时这种机制在进行 sunion 之类的比较耗时的命令时会使 Redis 的并发下降。因为是单一线程，所以同一时刻只有一个操作在进行，所以，耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。而单一线程也只能用到一个 CPU 核心，所以可以在同一个多核的服务器中，可以启动多个 Redis 实例，组成 master-master 或者 master-slave 的形式，耗时的读命令可以完全在 slave 中进行。\n\n### 二、内存利用率\n如果要说内存使用效率，使用简单的 key-value 存储的话，Memcached 的内存利用率更高，而如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩，其内存利用率会高于 Memcached。当然，这和你的应用场景和数据特性有关。\n##### Redis 的 hash 结构\nRedis 中不同的数据类型都有其不同的编码方式，拿 hash 来说，在 Redis 内部其实就是相当于一个 HashMap，但是它有两种不同的实现方式。当这个 hash 的成员较少时，Redis 为了节省内存会采用类似一维数组的方式使数据在内存中更加紧凑，而不会采用真正的 HashMap 结构，对应的编码方式为 zipmap。当这个 hash 的成员数量增大时会自动转换成真正的 HashMap，此时对应的编码方式为 ht。\n\n### 三、数据持久化与数据同步\n如果你对数据持久化和数据同步有所要求，那么推荐你选择 Redis，因为这两个特性 Memcached 都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择 Redis 也是明智的。、\n\n### 四、具体应用需求\n当然，最后还得说到你的具体应用需求。Redis 相比 Memcached 来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在 Memcached 里，你需要将数据拿到客户端来进行类似的修改再 set 回去。这大大增加了网络 I/O 的次数和数据体积。在 Redis 中，这些复杂的操作通常和一般的 GET/SET 一样高效。所以，如果你需要缓存能够支持更复杂的结构和操作，那么 Redis 会是不错的选择。\n\n> 参考：\n  [Redis 和 memory cache 的区别](https://www.jianshu.com/p/38e04b5a3e86)\n');

-- ----------------------------
-- Table structure for articlecategory
-- ----------------------------
DROP TABLE IF EXISTS `articlecategory`;
CREATE TABLE `articlecategory`  (
  `acid` int(11) NOT NULL AUTO_INCREMENT,
  `acName` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`acid`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of articlecategory
-- ----------------------------
INSERT INTO `articlecategory` VALUES (1, 'java');
INSERT INTO `articlecategory` VALUES (2, '数据结构');

-- ----------------------------
-- Table structure for attention
-- ----------------------------
DROP TABLE IF EXISTS `attention`;
CREATE TABLE `attention`  (
  `fuid` int(11) NOT NULL,
  `tuid` int(11) NOT NULL,
  PRIMARY KEY (`fuid`, `tuid`) USING BTREE,
  INDEX `tuid`(`tuid`) USING BTREE,
  CONSTRAINT `attention_ibfk_1` FOREIGN KEY (`fuid`) REFERENCES `user` (`uid`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `attention_ibfk_2` FOREIGN KEY (`tuid`) REFERENCES `user` (`uid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of attention
-- ----------------------------
INSERT INTO `attention` VALUES (2, 1);
INSERT INTO `attention` VALUES (3, 1);
INSERT INTO `attention` VALUES (1, 2);

-- ----------------------------
-- Table structure for collectarticle
-- ----------------------------
DROP TABLE IF EXISTS `collectarticle`;
CREATE TABLE `collectarticle`  (
  `uid` int(11) NOT NULL,
  `aid` int(11) NOT NULL,
  PRIMARY KEY (`uid`, `aid`) USING BTREE,
  INDEX `aid`(`aid`) USING BTREE,
  CONSTRAINT `collectarticle_ibfk_1` FOREIGN KEY (`uid`) REFERENCES `user` (`uid`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `collectarticle_ibfk_2` FOREIGN KEY (`aid`) REFERENCES `article` (`aid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of collectarticle
-- ----------------------------
INSERT INTO `collectarticle` VALUES (3, 2);
INSERT INTO `collectarticle` VALUES (4, 2);
INSERT INTO `collectarticle` VALUES (11, 2);

-- ----------------------------
-- Table structure for review
-- ----------------------------
DROP TABLE IF EXISTS `review`;
CREATE TABLE `review`  (
  `rid` int(11) NOT NULL AUTO_INCREMENT,
  `trid` int(11) DEFAULT NULL,
  `aid` int(11) DEFAULT NULL,
  `fuid` int(11) DEFAULT NULL,
  `likeCount` int(11) UNSIGNED ZEROFILL DEFAULT NULL,
  `reviewTime` timestamp(0) DEFAULT NULL,
  `content` tinytext CHARACTER SET utf8 COLLATE utf8_general_ci,
  PRIMARY KEY (`rid`) USING BTREE,
  INDEX `aid`(`aid`) USING BTREE,
  INDEX `fuid`(`fuid`) USING BTREE,
  INDEX `tuid`(`trid`) USING BTREE,
  CONSTRAINT `review_ibfk_1` FOREIGN KEY (`aid`) REFERENCES `article` (`aid`) ON DELETE RESTRICT ON UPDATE RESTRICT,
  CONSTRAINT `review_ibfk_2` FOREIGN KEY (`fuid`) REFERENCES `user` (`uid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB AUTO_INCREMENT = 26 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of review
-- ----------------------------
INSERT INTO `review` VALUES (22, -1, 2, 4, 00000000001, '2019-06-20 17:59:33', 'I\'m Jery!!!');
INSERT INTO `review` VALUES (24, -1, 3, 11, 00000000000, '2019-06-21 10:13:01', '我是ww');
INSERT INTO `review` VALUES (25, 22, 2, 3, 00000000002, '2019-06-21 10:13:42', '我是Tom');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `uid` int(11) NOT NULL AUTO_INCREMENT,
  `nickname` varchar(15) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(15) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  PRIMARY KEY (`uid`) USING BTREE,
  UNIQUE INDEX `user_nickname`(`nickname`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'Bob', 'Bob');
INSERT INTO `user` VALUES (2, 'Alice', 'Alice');
INSERT INTO `user` VALUES (3, 'Tom', 'Tom');
INSERT INTO `user` VALUES (4, 'Jery', 'Jery');
INSERT INTO `user` VALUES (7, 'Steven', 'Steven');
INSERT INTO `user` VALUES (8, 'Tx', 'Tx');
INSERT INTO `user` VALUES (9, 'Tx2', 'Tx2');
INSERT INTO `user` VALUES (10, 'Tx3', 'Tx3');
INSERT INTO `user` VALUES (11, 'ww', 'ww');

-- ----------------------------
-- Table structure for userinfo
-- ----------------------------
DROP TABLE IF EXISTS `userinfo`;
CREATE TABLE `userinfo`  (
  `uiid` int(11) NOT NULL,
  `sex` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL,
  `birthday` date DEFAULT NULL,
  `individualResume` tinytext CHARACTER SET utf8 COLLATE utf8_general_ci,
  `personalizedSignature` tinytext CHARACTER SET utf8 COLLATE utf8_general_ci,
  PRIMARY KEY (`uiid`) USING BTREE,
  CONSTRAINT `userinfo_ibfk_1` FOREIGN KEY (`uiid`) REFERENCES `user` (`uid`) ON DELETE RESTRICT ON UPDATE RESTRICT
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of userinfo
-- ----------------------------
INSERT INTO `userinfo` VALUES (1, '男', '2019-06-07', '若有恒，何必三更眠五更起', '读万卷书，行万里路');

SET FOREIGN_KEY_CHECKS = 1;
